\documentclass[a4paper, 12pt]{article}
\usepackage{graphicx}
\usepackage{url}
\usepackage[greek,english]{babel}
\usepackage[iso-8859-7]{inputenc}
\usepackage{kerkis}
\usepackage{listings}

\newcommand{\term}[1]{
    \emph{\textlatin{#1}}
}

\newcommand{\listCode}[1]{%
    \lstinputlisting[basicstyle=\footnotesize,stringstyle=\ttfamily,numbers=none
    ,showstringspaces=false, showlines=false,emptylines=0,lineskip=-11pt]{#1}
}

\begin{document}
  \selectlanguage{greek}
  \title{\textlatin{ASPA}}
  \author{Ανακρέων Μεντής}
  \maketitle
  \tableofcontents
\newpage
\begin{abstract}
Το έργο που επιτελεί το \textlatin{ASPA} είναι η μετάφραση σελίδων
που χρησιμοποιούν την \textlatin{ASP} \cite{bib:asp} σε ισοδύναμες λειτουργικά
σελίδες \textlatin{PHP} \cite{bib:php}.
Στόχος του \textlatin{ASPA} είναι η διευκόλυνση της μετάβασης διαδικτυακών
εφαρμογών υλοποιημένων σε \textlatin{ASP} στην ανοιχτού λογισμικού γλώσσα
\textlatin{PHP}.
Η \textlatin{ASP} υποστηρίζει πολλές γλώσσες προγραμματισμού, από τις οποίες το
\textlatin{ASPA} ερμηνεύει μόνο κώδικα γραμμένο σε \textlatin{JScript}
\cite{bib:jscript} ή \textlatin{VBScript} \cite{bib:vbscript}, μετατρέποντάς
τον σε \textlatin{PHP}. H \textlatin{PHP} εκτελείται σε πληθώρα υπολογιστικών
πλατφορμών και λειτουργικών συστημάτων, δίνοντας περισσότερες επιλογές για το
περιβάλλον ανάπτυξης και εκτέλεσης της εφαρμογής.
H \textlatin{PHP}, που είναι ταχύτερη από την  \textlatin{ASP}, αναπτύσσεται
και βελτιώνεται ραγδαία, απαιτεί λιγότερους πόρους και επιπλέον διαθέτει μεγάλο
πλήθος βιβλιοθηκών, που αυξάνουν την παραγωγικότητα του προγραμματιστή.
\end{abstract}
\newpage
\section{Εισαγωγή}

Την τελευταία δεκαετία, η ευρεία εξάπλωση του \textlatin{Internet} γέννησε
την ανάγκη ανάπτυξης ιστοσελίδων που θα παρείχαν δυναμικό περιεχόμενο.
Για την επίτευξη του στόχου αυτού προτάθηκε το πρότυπο \textlatin{CGI}
\cite{bib:cgi}.
Το \textlatin{CGI} ορίζει τον τρόπο αλληλεπίδρασης ενός προγράμματος με τον
εξυπηρετητή του πρωτοκόλλου \textlatin{HTTP (HTTP Server)}. Το \textlatin{CGI}
πρόγραμμα μπορεί να υλοποιηθεί σε οποιαδήποτε γλώσσα γνωστή στο σύστημα όπου
βρίσκεται ο \textlatin{HTTP} εξυπηρετητής. Υπάρχει η δυνατότητα υλοποίησης
προγραμμάτων \textlatin{CGI} σε
\begin{itemize}
    \item \textlatin{C/C++}
    \item \textlatin{Fortran}
    \item \textlatin{PERL}
    \item \textlatin{TCL}
    \item κέλυφος \textlatin{Unix}
    \item \textlatin{Python}
    \item και άλλα
\end{itemize}

Η κάθε γλώσσα από τις παραπάνω και όσες άλλες δεν αναφέραμε χάριν συντομίας,
προσφέρουν πλεονεκτήματα σε κάποια σημεία και μειονεκτούν σε άλλα. Ωστόσο
υπάρχουν μειονεκτήματα που απορρέουν από την άμεση χρήση του \textlatin{CGI}
ανεξάρτητα από την γλώσσα υλοποίησης του προγράμματος.
\begin{itemize}
\item Το πρόγραμμα \textlatin{CGI} ενεργοποιείται από εξωτερικές αιτήσεις προς
το σύστημα. Το φαινόμενο είναι ανάλογο με ένα πρόγραμμα που ο καθένας στον
κόσμο μπορεί να το εκτελέσει οποτεδήποτε. Καθίσταται φανερό πως πρόκειται για
τον εφιάλτη του διαχειριστή συστήματος. Για να αποφευχθούν δυσάρεστες
καταστάσεις, το \textlatin{CGI} πρόγραμμα οφείλει να είναι εξαιρετικά ασφαλές.

Η ανάπτυξη προγραμμάτων που εκτός από εύρυθμη λειτουργία, επιτυγχάνουν υψηλά
επίπεδα ασφάλειας, απαιτεί πολύ χρόνο για την υλοποίηση και αποσφαλμάτωση,
και μεγάλη εμπειρία. Συνήθως, ο χρόνος ενός έμπειρου προγραμματιστή κοστίζει
πολύ.

Αντίθετα, η \textlatin{ASP} και \textlatin{PHP} παρέχουν ασφαλέστερο
περιβάλλον εκτέλεσης για τις σελίδες. Αν και το πρόβλημα της ασφάλειας δεν έχει
αντιμετωπιστεί πλήρως, ο προγραμματιστής χρειάζεται να μεριμνά για
λιγότερα πιθανά σενάρια άλωσης του συστήματος.
\item Καμία από τις γλώσσες δεν έχει σχεδιαστεί για να αντιμετωπίσει
προβλήματα ιδιαίτερα στο \textlatin{CGI}. Είναι γλώσσες γενικής χρήσης. Συχνά
το κείμενο που παράγεται από το \textlatin{CGI} περιέχει δυναμικά και στατικά
μέρη. Τα στατικά τμήματα του κειμένου υπάρχουν ως αλφαριθμητικά στον κώδικα του
προγράμματος. Στην \textlatin{ASP} και \textlatin{PHP} τα στατικά μέρη μπορούν
να τοποθετηθούν εκτός του κώδικα που παράγει τα δυναμικά κομμάτια, με αποτέλεσμα
ο κώδικας να είναι πιο ευανάγνωστος.
\item Δεδομένα που στάλθηκαν στην σελίδα με τις μεθόδους \textlatin{GET} και
\textlatin{POST} είναι προσβάσιμα στο \textlatin{CGI} μέσω μεταβλητών
περιβάλλοντος (\textlatin{environment variable}) και της προκαθορισμένης εισόδου
(\textlatin{standard input}) αντίστοιχα. Για την απόκτηση της πληροφορίας που
υπάρχει σε αυτά τα δεδομένα, απαιτείται η συγγραφή ρουτινών στην γλώσσα του
\textlatin{CGI} προγράμματος ή η χρήση επιπλέον βιβλιοθηκών. Τόσο η
\textlatin{ASP} όσο και η \textlatin{PHP} προσφέρουν τις παραπάνω πληροφορίες
στον προγραμματιστή, χωρίς επιπλέον κόπο. Πρέπει να τονίσουμε πως η
χρήση μεταβλητών περιβάλλοντος για τα δεδομένα τα οποία έχουν σταλεί με την
μέθοδο \textlatin{GET} παρουσιάζει το ενδεχόμενο κορεσμού των ενταμιευτών
(\textlatin{buffer overflow}) με πιθανές σοβαρές συνέπειες για την ασφάλεια.
\end{itemize}

Λόγω των όσων αναφέραμε, η ανάπτυξη εφαρμογών \textlatin{Internet} με άμεση
χρήση του \textlatin{CGI} αποδεικνύεται δύσκολη, χρονοβόρα και ενίοτε
επικίνδυνη.

Για τη διευκόλυνση και την αύξηση της παραγωγικότητας στον παραπάνω τομέα
παρουσιάστηκαν νεότερες τεχνολογίες, που βασίζονται σε γλώσσες σεναρίων
(\textlatin{Scripting Languages}).
Δύο από αυτές είναι η \textlatin{ASP} και η \textlatin{PHP}, που είναι αρκετά
διαδεδομένες.

Στόχος της παρούσας εφαρμογής είναι η αυτοματοποίηση της μετατροπής
του κώδικα εφαρμογών υλοποιημένων σε \textlatin{ASP} στη γλώσσα ανοιχτού
λογισμικού  \textlatin{PHP}.
Επειδή η \textlatin{PHP}, είναι, όπως αναφέρθηκε, γλώσσα ανοιχτού λογισμικού,
αποκτά πλεονεκτήματα και μόνο από το γεγονός αυτό.
Ο πηγαίος κώδικας της \textlatin{PHP} είναι διαθέσιμος, αποκλείοντας
την ύπαρξη κρυφών και ανεπιθύμητων χαρακτηριστικών. Η ομάδα των ατόμων ανά
την υφήλιο που ασχολούνται με την ανάπτυξη και βελτίωση της \textlatin{PHP}
είναι πολυπληθής, γεγονός που συντελεί στον άμεσο εντοπισμό λαθών και στη
γρήγορη διόρθωσή τους. Επιπλέον, το μέλλον της \textlatin{PHP} δεν
καθορίζεται από κάποια εταιρία, με αποτέλεσμα η πορεία της να είναι ανεξάρτητη
από εκείνη της εταιρίας. Από μετρήσεις που έχουν πραγματοποιηθεί, έχει
διαπιστωθεί πως η \textlatin{PHP} εκτελείται ταχύτερα, απαιτώντας συνάμα
λιγότερους πόρους. Επιπρόσθετα, το μεγάλο πλήθος βιβλιοθηκών διαθέσιμων στην
\textlatin{PHP} αυξάνουν την παραγωγικότητα του προγραμματιστή. Βιβλιοθήκες
βέβαια είναι διαθέσιμες και στην \textlatin{ASP}, σε μορφή \textlatin{ActiveX}
\cite{bib:activex}, όμως οι βιβλιοθήκες της \textlatin{PHP} είναι στην
πλειοψηφία τους προϊόντα ανοιχτού λογισμικού και προσφέρονται δωρεάν.

Για τους παραπάνω λόγους, η επιλογή της \textlatin{PHP} στην ανάπτυξη
\textlatin{web} εφαρμογών είναι προτιμητέα. Επειδή η \textlatin{ASP} είναι
αρκετά διαδεδομένη στον τομέα της ανάπτυξης \textlatin{web} εφαρμογών,
όσοι την υιοθέτησαν και αποφασίζουν να μεταβούν σε \textlatin{PHP},
καλούνται να μεταφράσουν τις εφαρμογές τους. Η παραπάνω διαδικασία είναι
χρονοβόρα και επιρρεπής σε λάθη, γι αυτό το κόστος της μετάβασης, ανάλογα με
το μέγεθος της εφαρμογής, είναι ιδιαίτερα υψηλό.
Αυτό αποτελεί ανασταλτικό παράγοντα στην υιοθέτηση της \textlatin{PHP},
παρ' όλα τα σημαντικά της πλεονεκτήματα.

Το \textlatin{ASPA} αυτοματοποιεί τη διαδικασία μετάφρασης της εφαρμογής,
μειώνοντας κατά πολύ τον απαιτούμενο για τη μετάφραση χρόνο, ενώ συνάμα
αποφεύγονται τα λάθη.
Δίνει λοιπόν τη δυνατότητα να διαπιστώσει κάποιος έμπρακτα τα πλεονεκτήματα
της \textlatin{PHP}. Αναμένεται πως η διευκόλυνση που παρέχει η εφαρμογή στη
μετάφραση, θα άρει τον ανασταλτικό παράγοντα του κόστους, με αποτέλεσμα την
ευρύτερη χρήση της \textlatin{PHP}. Αυτό με τη σειρά του θα επιφέρει την
ενίσχυση του κινήματος του ανοιχτού λογισμικού.



\section{Έρευνα}

Η αναγκαιότητα ύπαρξης μεταφραστή από \textlatin{ASP} σε \textlatin{PHP} έχει
αναγνωριστεί και από άλλους μηχανικούς λογισμικού. Υπάρχουν τουλάχιστον δυο άλλες
προσπάθειες κατασκευής ενός μεταφραστή.

Ο δημοφιλέστερος μεταφραστής είναι ο \textlatin{asp2php} \cite{bib:asp2php}. Το
πρόγραμμα είναι ανοιχτού λογισμικού και διανέμεται υπό την άδεια
\textlatin{GPL}\cite{bib:gpl}. Το \textlatin{asp2php} υποστηρίζει μόνο την
\textlatin{VbScript} ενώ η υποστήριξη της \textlatin{JScript} βρίσκεται στα
πρώτα της βήματα. Η στρατηγική μετάφρασης που ακολουθεί το \textlatin{asp2php}
περιορίζει σημαντικά την αποτελεσματικότητά του.

Η έλλειψη υποστήριξης της \textlatin{JScript} αποκλείει την αξιοποίηση του
προγράμματος για μετάφραση σελίδων που κάνουν χρήση της παραπάνω γλώσσας.
Επιπλέον, το \textlatin{asp2php} υποστηρίζει λίγα μόνα \textlatin{ActiveX}.
Εάν μία σελίδα αναφέρεται σε ιδιότητες ή μεθόδους ενός \textlatin{ActiveX} που
δεν υποστηρίζει το \textlatin{asp2php} τότε η μοναδική επιλογή που απομένει
είναι η συγγραφή μεθόδων σε \textlatin{C} και η επαναμεταγλώττιση του
προγράμματος. Το πρόγραμμα δεν επιχειρεί να κατανοήσει τον κώδικα της σελίδας
αλλά αντικαθιστά γνωστές μορφές και δομές κώδικα με προκαθορισμένες αντίστοιχες
δομές της \textlatin{PHP}. Η τεχνική αυτή αποδεικνύεται στην πράξη ανεπαρκής.

Ο δεύτερος μεταφραστής \cite{bib:jstrans} είναι υλοποιημένος σε
\textlatin{JScript} και εκτελείται μέσα στο περιβάλλον που παρέχει ένας
φυλλομετρητής (\textlatin{Browser}).Το πρόγραμμα χρησιμοποιεί κανονικές
εκφράσεις για να αντικαταστήσει τα ονόματα των μεταβλητών με ονόματα συμβατά με
την \textlatin{PHP}.
Ουσιαστικά δεν πρόκειται για μεταφραστή αφού το μόνο που κάνει είναι
η τυφλή αντικατάσταση ορισμένων χαρακτήρων από άλλους.

Η εξέταση των δύο διαθέσιμων προγραμμάτων, συνηγορεί υπέρ της άποψης πως δεν
έχει δοθεί ακόμη μία ικανοποιητική λύση στο πρόβλημα του αυτοματισμού της
μετάφρασης της \textlatin{ASP} σε \textlatin{PHP}. Το \textlatin{ASPA} επιχειρεί
να δώσει μια ικανοποιητικότερη λύση στο πρόβλημα.

Ο παράγοντας που συνέβαλε καθοριστικά στην μικρή επιτυχία των παραπάνω
προγραμμάτων είναι η αξιοποίηση κανονικών εκφράσεων για την ανάλυση του κώδικα.
Έπρεπε να βρεθεί μία στρατηγική η οποία αποδεδειγμένα έχει πετύχει σε παρόμοια
προβλήματα και εργαλεία που θα έκαναν το εγχείρημα ευκολότερο στην υλοποίηση του.

Η δική μας προσέγγιση έπρεπε να παρέχει την δυνατότητα κατανόησης του κώδικα της
σελίδας \textlatin{ASP} ώστε να είναι εφικτή η αντικατάσταση εκφράσεων της
\textlatin{ASP} με ισοδύναμες εκφράσεις της \textlatin{PHP}. Επιπλέον, η
αρχιτεκτονική του προγράμματος έπρεπε να είναι ανοιχτή ώστε να διευκολύνεται
η περαιτέρω ανάπτυξη και επέκταση των δυνατοτήτων του. Τέλος,
επειδή η \textlatin{ASP} βασίζεται στην χρήση βιβλιοθηκών \textlatin{ActiveX} θα
ήταν θεμιτό η απαραίτητη γνώση για την μετάφραση των μεθόδων και ιδιοτήτων των
\textlatin{ActiveX} να μην είναι ενσωματωμένη στο πρόγραμμα, αλλά να παρέχεται
κατά την εκτέλεση του προγράμματος. Η παραπάνω δυνατότητα θα εξασφάλιζε την
εύκολη επέκταση των δυνατοτήτων του προγράμματος, χωρίς να απαιτείται αλλαγή
του πηγαίου κώδικα και κατανόηση των εσωτερικών δομών του.

Η αναζήτηση εργαλείων και τεχνολογιών που θα ικανοποιούσαν τις παραπάνω
απαιτήσεις απέδωσε. Το \textlatin{ASPA} σχεδιάστηκε με πρότυπο την μεθοδολογία
ανάπτυξης μεταγλωττιστών, μία τεχνολογία δοκιμασμένη στην πράξη για πολλές
δεκαετίες και με πλούσια τεχνογνωσία.

\subsection{Γλώσσα Προγραμματισμού}
Η γλώσσα προγραμματισμού είναι η \textlatin{Java}\cite{bib:java}.
Η \textlatin{Java} επιλέχτηκε για τους παρακάτω λόγους:
\begin{itemize}
    \item Είναι αντικειμενοστραφής γλώσσα. Το πρόγραμμα αποτελείται από μία
    συλλογή αντικειμένων που αλληλεπιδρούν και συνεργάζονται για την παραγωγή
    του τελικού αποτελέσματος. Κάθε αντικείμενο αναλαμβάνει να φέρει εις πέρας
    την επίλυση ενός καλώς καθορισμένου υποπροβλήματος. Ο σχεδιασμός του
    προγράμματος εν γένει είναι ευκολότερα κατανοητός. Η σωστή λειτουργία κάθε
    αντικειμένου μπορεί να ελεγχθεί ανεξάρτητα από τα υπόλοιπα αντικείμενα, με
    αποτέλεσμα ο έλεγχος της αξιόπιστης λειτουργίας του προγράμματος να
    καθίσταται εφικτός και σχετικά εύκολος.
    \item Τα προγράμματα υλοποιημένα σε \textlatin{Java} εκτελούνται
    σε μια νοητή μηχανή \textlatin{(virtual machine)}, με αποτέλεσμα την αποφυγή
    επικίνδυνων λαθών τα οποία προέρχονται από εσφαλμένες υποθέσεις για την δομή
    της μηχανής και υπηρεσιών που προσφέρει το λειτουργικό σύστημα.
    \item Τα προγράμματα γραμμένα σε \textlatin{Java} εκτελούνται σε πολλά
    λειτουργικά συστήματα χωρίς να απαιτείται επαναμεταγλώττιση, οπότε δεν
    αποτρέπεται η χρήση του \textlatin{ASPA} λόγω διαφορετικού λειτουργικού
    συστήματος.
\end{itemize}

\subsection{Σχηματική αναπαράσταση της μετάφρασης}
\includegraphics{flow}
Στο παραπάνω διάγραμμα παρουσιάζονται τα στάδια μετατροπής του αρχικού κώδικα
\textlatin{ASP} που απαιτούνται για την παραγωγή του κώδικα \textlatin{PHP}.

Το πρόγραμμα δέχεται ως είσοδο το κώδικα
\selectlanguage{english}
\verb+Response.write "Hello World"+.
\selectlanguage{greek} Ανάλογα με την γλώσσα του κώδικα, επιλέγεται ο κατάλληλος
λεκτικός αναλυτής(\textlatin{lexer} \cite{bib:lexer}). Ο λεκτικός αναλυτής
μετατρέπει τον κώδικα της \textlatin{ASP} σε ροή από \textlatin{token}
\cite{bib:token} που τροφοδοτούν τον συντακτικό αναλυτή. Ο συντακτικός αναλυτής,
από τα \textlatin{token} εισόδου, παράγει ένα δέντρο \textlatin{AST}, το οποίο
αποτελεί την είσοδο του αναλυτή δέντρων.

Ο αναλυτής δέντρων, μετατρέπει το \textlatin{AST} που δέχθηκε ως είσοδο σε
\textlatin{AST} που αντιπροσωπεύει κώδικα \textlatin{PHP}, αξιοποιώντας
πληροφορίες τις οποίες συνέλεξε ο συντακτικός αναλυτής και τις πληροφορίες
που βρίσκονται στα \textlatin{XML} \cite{bib:xml} αρχεία.

Το τελικό \textlatin{AST} που παράγει ο αναλυτής δέντρων, τροφοδοτεί τον
παραγογέα κώδικα που το μετατρέπει σε κώδικα \textlatin{PHP}.

\subsection{Αναλυτές}
Για τη συγγραφή του λεκτικού αναλυτή εξετάστηκαν τα εργαλεία \textlatin{JFlex}
\cite{bib:jflex}, \textlatin{JavaCC} \cite{bib:javacc} και \textlatin{Antlr}
\cite{bib:antlr}. Το καθένα από αυτά χρησιμοποιεί μια γλώσσα με τη βοήθεια της
οποίας δημιουργείται ο λεκτικός αναλυτής. Σε αντιδιαστολή με τη
\textlatin{Java}, οι γλώσσες των παραπάνω εργαλείων σχεδιάστηκαν με σκοπό την
εύκολη περιγραφή λεκτικών αναλυτών, με αποτέλεσμα την ταχύτερη και ευκολότερη
ανάπτυξη του λεκτικού αναλυτή.

\subsubsection{\textlatin{JFlex}}
Η ομοιότητα της σύνταξης της γλώσσας του \textlatin{JFlex} με εκείνη του
\textlatin{flex} \cite{bib:gnuflex}, ενός καθιερωμένου εργαλείου για την
παραγωγή λεκτικών αναλυτών, αποτελεί σημαντικό πλεονέκτημα, διότι δεν θα ήταν
αναγκαία η εκμάθηση κάποιας νέας σύνταξης άλλου εργαλείου. Επιπλέον, το
\textlatin{JFlex} έχει πλήρη υποστήριξη \textlatin{Unicode} και παράγει
γρήγορους αναλυτές. Παρ' όλα τα πλεονεκτήματά του, το \textlatin{JFlex}
απορρίφθηκε, διότι δεν κατασκευάζει συντακτικούς αναλυτές, με αποτέλεσμα να
απαιτείται η χρήση και άλλων εργαλείων.

\subsubsection{\textlatin{JavaCC}}
Σε αντίθεση με το \textlatin{JFlex}, το \textlatin{JavaCC} παρέχει τη δυνατότητα
παραγωγής λεκτικών, αλλά και συντακτικών αναλυτών. Επιπλέον, με τη βοήθεια
επιπρόσθετων εργαλείων, διευκολύνει στο έργο κατασκευής δέντρων \textlatin{AST}
\cite{bib:ast}. Υποστηρίζει πλήρως το \textlatin{Unicode} και έχει σύνταξη όμοια
με το \textlatin{EBNF} \cite{bib:ebnf}, που είναι ευρέως γνωστή στην τεχνολογία
ανάπτυξης μεταγλωττιστών. Όμως απορρίφθηκε, διότι η μετάβασης του
\textlatin{JavaCC} σε έργο ανοιχτού λογισμικού συνέβει αφότου ξεκίνησε η
ανάπτυξη του \textlatin{ASPA}. Εκτός από αυτό, το \textlatin{JavaCC} δεν
προσφέρει εργαλεία για την κατασκευή αναλυτών δέντρων \textlatin{AST}.

\subsubsection{\textlatin{Antlr}}
Τελικά, αυτό που επιλέχθηκε είναι το \textlatin{Antlr}, λόγω των πλεονεκτημάτων
που συγκεντρώνει. Κατ' αρχήν, το \textlatin{Antlr} στηρίζει όλα τα στάδια
ανάπτυξης των αναλυτών που χρησιμοποιεί το \textlatin{ASPA}. Κατασκευάζει
λεκτικούς και συντακτικούς αναλυτές, καθώς και αναλυτές δέντρων. Είναι επίσης
πρόγραμμα ανοιχτού λογισμικού, το οποίο στηρίζεται από μια μεγάλη κοινότητα
χρηστών, που υπήρξε πρόθυμη να απαντήσει σε ερωτήσεις που προέκυπταν κατά
την ανάπτυξη του \textlatin{ASPA}. Ένα μειονέκτημα που παρουσιάζει το
\textlatin{Antlr} είναι το γεγονός πως οι λεκτικοί αναλυτές που παράγει
υπολείπονται σε ταχύτητα αυτών που παράγουν τα προαναφερθέντα εργαλεία. Το
πρόβλημα αναμένεται να επιλυθεί στην επόμενη έκδοση του \textlatin{Antlr}.

\subsection{Αναπαράσταση δέντρων}
Για την περιγραφή των βιβλιοθηκών \textlatin{ActiveX}, επιλέχθηκε η γλώσσα
\textlatin{XML}. Τα αντικείμενα \textlatin{ActiveX} περιέχουν μεθόδους και
ιδιότητες, στην κάθε μια εκ των οποίων αντιστοιχούμε ένα υποδέντρο
\textlatin{AST}. Αναζητήσαμε ένα τρόπο αποθήκευσης και απεικόνισης της παραπάνω
αντιστοιχίας. Η ιδανική απάντηση σε αυτή την απαίτηση βρέθηκε στη γλώσσα
\textlatin{XML}, λόγω της ομοιότητας που παρουσιάζει με το \textlatin{AST}, όσον
αφορά τη δενδρική τους δομή. Επιπρόσθετα, η ευρεία διάδοση της \textlatin{XML}
εξασφαλίζει την άμεση κατανόηση της περιγραφής των \textlatin{ActiveX} και
επομένως την εύκολη τροποποίηση του εγγράφου \textlatin{XML}. Τέλος, υπάρχουν
έτοιμες βιβλιοθήκες που αναλαμβάνουν την αποκωδικοποίηση των εγγράφων
\textlatin{XML}, οπότε δε χρειάστηκε η ανάπτυξή τους εκ μέρους μας.

\subsection{Χειρισμός \textlatin{XML} αρχείων}
Αναζητήσαμε βιβλιοθήκες σε \textlatin{Java} που μετατρέπουν τα \textlatin{XML}
αρχεία σε δομές δεδομένων εύκολων στον χειρισμό τους. Από το \textlatin{W3C}
\cite{bib:w3c} έχουν οριστεί δύο τρόποι επεξεργασίας \textlatin{XML} αρχείων, το
\textlatin{DOM} \cite{bib:dom} και το \textlatin{SAX} \cite{bib:sax}. Ήταν
θεμιτό να αποφευχθεί η χρήση βιβλιοθηκών που βασίζονται στην απευθείας
αξιοποίηση των παραπάνω ορισμών, καθώς υπάρχουν βιβλιοθήκες που παρέχουν δομές
δεδομένων ευκολότερες για των χειρισμό της πληροφορίας που αποθηκεύεται στα
\textlatin{XML} έγγραφα. Εξετάστηκαν οι βιβλιοθήκες \textlatin{JDOM}
\cite{bib:jdom} και \textlatin{dom4j} \cite{bib:dom4j} που λαμβάνουν υπόψιν
ιδιαίτερες ανάγκες της \textlatin{Java} και είναι ανοιχτού λογισμικού. Τελικά
επιλέχθηκε το \textlatin{dom4j} διότι καταναλώνει λιγότερη μνήμη και υποστηρίζει
και τα δύο μοντέλα επεξεργασίας που προτείνει το \textlatin{W3C}.

\subsection{Έλεγχος Εγκυρότητας}
Κατά τη διάρκεια ανάπτυξης του \textlatin{ASPA} κάθε τροποποίηση ενείχε τον
κίνδυνο πρόκλησης δυσλειτουργίας σε ένα από τα τμήματά του. Ήταν λοιπόν
απαραίτητο να βρεθεί μια μέθοδος που θα αυτοματοποιούσε τον έλεγχο της άρτιας
λειτουργίας του προγράμματος. Για τον παραπάνω έλεγχο χρησιμοποιήθηκε το
\textlatin{JUnit} \cite{bib:junit}, μια βιβλιοθήκη η οποία παρέχει το περιβάλλον
για την υλοποίηση των ελέγχων. Το \textlatin{JUnit} είναι ένα από τα αρχικά
περιβάλλοντα ανοιχτού λογισμικού που παρείχαν υπηρεσίες ελέγχου εγκυρότητας για
τη \textlatin{Java}.

\subsection{Εργαλεία Αυτοματοποίησης \textlatin{(build tools)}}
Το \textlatin{Ant} \cite{bib:ant} είναι ένα εργαλείο που αυτοματοποιεί συχνά
εκτελούμενες διαδικασίες, όπως τη μεταγλώττιση του πηγαίου κώδικα,
την κατασκευή \textlatin{jar} αρχείων, την εκτέλεση του ελέγχου εγκυρότητας κ. α.
Εναλλακτικό εργαλείο για την εκτέλεση των παραπάνω εργασιών είναι το
\textlatin{make} σε \textlatin{Unix} συστήματα. Το πλεονέκτημα του
\textlatin{Ant} έγκειται στο ότι χρησιμοποιεί ένα \textlatin{XML} αρχείο
για την περιγραφή των εργασιών και είναι υλοποιημένο σε \textlatin{Java},
με αποτέλεσμα οι εργασίες να  μπορούν να εκτελεστούν και σε άλλα λειτουργικά
συστήματα. Επιπλέον, το \textlatin{Ant} συνεργάζεται άμεσα με τα υπόλοιπα
εργαλεία που αξιοποιεί το \textlatin{ASPA}.


\section{Σχεδιασμός}
Το \textlatin{ASPA} αξιοποιεί την εμπειρία που έχει αποκομισθεί στον τομέα της
ανάπτυξης μεταγλωττιστών και χρησιμοποιεί μεθοδολογίες που έχουν εφαρμοστεί
με επιτυχία στο παρελθόν. Με βάση τις τεχνολογίες αυτές, η ανάλυση του κώδικα
πραγματοποιείται σε ξεχωριστά επίπεδα. Κάθε επίπεδο ανάλυσης φέρει εις πέρας μια
συγκεκριμένη εργασία και είναι ανεξάρτητο από τα υπόλοιπα. Αυτό το μοντέλο
επεξεργασίας διασφαλίζει την ταχύτερη ανάπτυξη του μεταγλωττιστή και διευκολύνει
τη διαδικασία διόρθωσης προγραμματιστικών λαθών και τη μελλοντική επέκταση
της εφαρμογής.

Το μοντέλο ανάπτυξης μεταγλωττιστών υπαγορεύει τέσσερα βασικά επίπεδα ανάλυσης:
\begin{itemize}
      \item \textit{Λεκτική Ανάλυση}. Σε αυτό το στάδιο ο πηγαίος κώδικας
      μετατρέπεται σε μια σειρά από απλές δομές δεδομένων, που στη διεθνή
      βιβλιογραφία αποκαλούνται \textlatin{tokens}. Η λεκτική ανάλυση
      εξασφαλίζει ότι ο πηγαίος κώδικας περιέχει λέξεις έγκυρες για τη γλώσσα
      του μεταγλωττιστή.
      \item \textit{Συντακτική Ανάλυση}. Στο επίπεδο της συντακτικής ανάλυσης
      ελέγχεται αν η σειρά των \textlatin{tokens} που παρήχθησαν στο προηγούμενο
      στάδιο είναι συντακτικά ορθή. Παράγωγο αυτής της διαδικασίας είναι ένα
      δέντρο, το οποίο αντανακλά τις συντακτικές δομές του πηγαίου κώδικα.
      \item \textit{Μετάφραση}. Στο τρίτο στάδιο ανάλυσης γίνεται η μετατροπή
      του παραπάνω δέντρου σε ένα δεύτερο, που υπακούει στη σύνταξη της προς
      μετατροπή γλώσσας, στην προκειμένη περίπτωση της \textlatin{PHP}. Επιπλέον,
      κατά τη μετατροπή συντελούνται βελτιώσεις του κώδικα.
      \item \textit{Παραγωγή Κώδικα}. Στο τέταρτο επίπεδο, το τελικό δέντρο
      μετατρέπεται σε πηγαίο κώδικα της \textlatin{PHP}. Το τελευταίο αυτό
      στάδιο εξασφαλίζει την εγκυρότητα των ονομάτων των μεταβλητών,
      μετονομάζοντας όσες παραβιάζουν κανόνες ονοματοδοσίας της \textlatin{PHP}.
\end{itemize}


\subsection{Είσοδος προγράμματος}
Η εφαρμογή δέχεται ως είσοδο αρχεία \textlatin{ASP}.
Κάθε σελίδα \textlatin{ASP} περιέχει:
\begin{itemize}
  \item Τον καθορισμό της γλώσσας του κώδικα.
  Η πρώτη εντολή της \textlatin{ASP} ορίζει τη γλώσσα του κώδικα που περιέχεται
  στη σελίδα. Για παράδειγμα, η εντολή
  \textlatin{\textless \%@Language="VbScript"\%>}
  ορίζει ως γλώσσα τη \textlatin{VbScript}.
  Αν παραλείπεται ο καθορισμός της γλώσσας της σελίδας, τότε υπονοείται η
  προκαθορισμένη γλώσσα.
  \item Εντολές που εισάγουν κώδικα από άλλα αρχεία. Για παράδειγμα η εντολή
  \textlatin{\textless !--\#include file="file1.asp"-->} εισάγει το περιεχόμενο
  του αρχείου \textlatin{file1.asp}
  \item Απλό κείμενο(συνήθως είναι κώδικας \textlatin{HTML})
  \item Κώδικας σε κάποια ερμηνευόμενη γλώσσα όπως
      \begin{itemize}
      \item[-] \textlatin{JScript}
      \item[-] \textlatin{VBScript}
      \item[-] \textlatin{Perl}
      \item[-] \textlatin{Python}
      \item[-] και άλλα
    \end{itemize}
    Το πρόγραμμα ερμηνεύει μόνο κώδικα γραμμένο σε \textlatin{JScript}
    ή \textlatin{VBScript}
\end{itemize}

\subsection{Λεκτική Ανάλυση}
Λεκτική ανάλυση είναι η διαδικασία αναγνώρισης τμημάτων του κειμένου εισόδου
ως λέξεις της γλώσσας προγραμματισμού. Παράγωγα αυτής της διαδικασίας είναι
τα \textlatin{tokens}. Υπάρχουν διάφοροι τύποι \textlatin{token}, όπως
μεταβλητές, λέξεις κλειδιά, τελεστές κ. α.
Ουσιαστικά είναι δομές δεδομένων που περιέχουν τις παρακάτω πληροφορίες:
\begin{itemize}
    \item Έναν κωδικό αριθμό που καθορίζει τον τύπο του.
    \item Το κείμενο που αντιστοιχεί στο \textlatin{token}
    \item Τη γραμμή και στήλη όπου βρέθηκε
\end{itemize}

Αν κάποιο τμήμα του κειμένου δεν αποτελεί λέξη της γλώσσας τότε δεν
αναγνωρίζεται, δεν σχηματίζει \textlatin{token} και η διαδικασία τερματίζεται.

\subsection{Συντακτική Ανάλυση}
Κατά τη συντακτική ανάλυση, η σειρά από \textlatin{tokens} που παρήχθησαν
ελέγχεται για τη συντακτική της ορθότητα. Τη διαδικασία αυτή υλοποιεί ο
Συντακτικός Αναλυτής (\textlatin{Parser} \cite{bib:parser}. Αν ο Συντακτικός
Αναλυτής διαπιστώσει παραβίαση των συντακτικών κανόνων στη σειρά των
\textlatin{tokens} ενημερώνει το χρήστη για το σφάλμα και τερματίζει τη
διαδικασία. Από τη συντακτική ανάλυση προκύπτουν δύο παράγωγα.

Το πρώτο είναι μια δενδροειδής απεικόνιση του κώδικα.
Η δενδροειδής δομή αποκαλείται στη διεθνή βιβλιογραφία
\textlatin{Abstract Syntax Tree (AST)}.
Κάθε κόμβος του δένδρου περιέχει ένα \textlatin{token}. Το δέντρο δεν αποτελεί
αντιγραφή του αρχικού συνόλου των \textlatin{tokens} διότι ορισμένοι κόμβοι
φέρουν \textlatin{token} το οποίο δεν προήλθε από το πηγαίο κώδικα, ενώ ορισμένα
από τα αρχικά \textlatin{tokens} αποβάλλονται διότι η πληροφορία που περιέχουν
αντανακλάται στη δομή του δέντρου.

Το δεύτερο παράγωγο της συντακτικής ανάλυσης είναι πληροφορίες σχετικές με
τύπους μεταβλητών, κλάσεις και μεθόδους. Οι πληροφορίες αυτές θα χρησιμοποιηθούν
στο επόμενο στάδιο ανάλυσης.

\subsection{Μετάφραση}
Στο στάδιο της μετάφρασης κάθε συντακτική δομή της \textlatin{JScript} και
\textlatin{VBScript} μετατρέπεται στην αντίστοιχη δομή της \textlatin{PHP}.
Διακρίνουμε τρεις συντακτικές δομές προς μετάφραση, η καθεμιά από τις οποίες
έχει διαφορετική αντιμετώπιση:
\begin{itemize}
    \item Εκφράσεις, τελεστές και εντολές.
    \item Συναρτήσεις και κλάσεις που ορίζονται στον κώδικα της σελίδας από
    το χρήστη.
    \item Συναρτήσεις και κλάσεις τις οποίες παρέχουν οι επιμέρους γλώσσες της
    \textlatin{ASP (VBScript, JScript)}, καθώς και μέθοδοι και ιδιότητες που
    παρέχονται από \textlatin{ActiveX} βιβλιοθήκες.
\end{itemize}

\subsubsection{Τελεστές}
Όσον αφορά τους τελεστές, διακρίνουμε δύο περιπτώσεις:
\begin{itemize}
    \item Τελεστές της \textlatin{JScript} ή \textlatin{VBScript} που δεν
    έχουν αντίστοιχο στην \textlatin{PHP}. Στην περίπτωση αυτή, οι τελεστές
    αντικαθίστονται από ισοδύναμες εκφράσεις της \textlatin{PHP}.
    \item Τελεστές που έχουν αντίστοιχο στην \textlatin{PHP}, αλλά ο αντίστοιχος
    τελεστής της \textlatin{PHP} διαφέρει ανάλογα με τα συμφραζόμενα.
    Για παράδειγμα, ο τελεστής άθροισης της \textlatin{JScript}  άλλοτε
    αντιστοιχεί στον τελεστή άθροισης της \textlatin{PHP} και άλλοτε στον
    τελεστή συνένωσης αλφαριθμητικών.
\end{itemize}

\subsubsection{Συναρτήσεις και κλάσεις του χρήστη}
Οι συναρτήσεις και οι κλάσεις που ορίζονται στον κώδικα της \textlatin{ASP}
μετατρέπονται σε αντίστοιχες συναρτήσεις και κλάσεις της \textlatin{PHP}.
Οι συναρτήσεις (\textlatin{functions}) υλοποιημένες σε \textlatin{JScript}
ή \textlatin{VBScript}
ενδέχεται να μην επιστρέψουν τιμή. Σε αυτή την περίπτωση, μετά τη μετάφραση
η αντίστοιχη συνάρτηση θα επιστρέψει την τιμή \textlatin{null}.

\subsubsection{\textlatin{ActiveX}}
Για τη μετάφραση των κλάσεων, μεθόδων και ιδιοτήτων που παρέχει η
\textlatin{ASP} ή οι \textlatin{ActiveX} βιβλιοθήκες χρησιμοποιούνται
αρχεία \textlatin{XML}, τα οποία ορίζουν τις αντίστοιχες μεθόδους της
\textlatin{PHP}. Τα αρχεία \textlatin{XML} περιγράφουν το σύνολο των παραμέτρων
της εκάστοτε μεθόδου και τον τύπο των επιστρεφόμενων τιμών, πληροφορία ουσιώδη
για την επιλογή της καταλληλότερης μεθόδου.

\subsubsection{Κανόνες ορατότητας}
Τέλος πρέπει να τονιστεί πως το \textlatin{ASPA} σέβεται τους
κανόνες ορατότητας \textlatin{(scope)} των μεταβλητών, των μεθόδων και των
κλάσεων της \textlatin{JScript} και \textlatin{VBScript}. Κατανοεί
δηλαδή πότε μια μεταβλητή, μέθοδος ή κλάση είναι προσπελάσιμη σε κάποιο
συγκεκριμένο σημείο του κώδικα.
Στην  περίπτωση μη έγκυρης προσπέλασης, το \textlatin{ASPA} ενημερώνει το χρήστη
για το λάθος.


\subsection{Παραγωγή κώδικα}
Σε αυτό το στάδιο πραγματοποιείται η παραγωγή του κώδικα  από το τελικό δέντρο
που κατασκευάστηκε στο προηγούμενο επίπεδο. Λαμβάνοντας υπόψιν πως ο παραγόμενος
κώδικας ενδέχεται να υποστεί αλλαγές, ήταν αναγκαίο να είναι ευανάγνωστος. Για
το λόγο αυτό το παρόν στάδιο μεριμνά για τη σωστή μορφή και στοίχιση του κώδικα.
Τα ονόματα των μεταβλητών, μεθόδων και κλάσεων δεν αλλάζουν κατά την παραγωγή
κώδικα, εκτός και αν παραβιάζεται κανόνας ονοματοδοσίας της \textlatin{PHP}.


\section{Υλοποίηση}
\subsection{Λεκτικοί Αναλυτές}
Το \textlatin{ASPA} αξιοποιεί τρεις λεκτικούς αναλυτές για την μετατροπή του
πηγαίου κώδικα μιας σελίδας \textlatin{ASP} σε \textlatin{tokens}. Καθένας από
τους λεκτικούς αναλυτές αναλαμβάνει ένα τμήμα του πηγαίου κώδικα, όταν είναι
υλοποιημένο στην γλώσσα που αναγνωρίζει.

\subsubsection{Λεκτικός αναλυτής της \textlatin{HTML}}
Ο λεκτικός αναλυτής μετατρέπει το κείμενο που παρεμβάλλεται μεταξύ δύο τμημάτων
κώδικα σε \textlatin{JScript} ή \textlatin{VbScript} σε \textlatin{tokens}.
Η μορφή του κειμένου γενικά δεν ενδιαφέρει την \textlatin{ASP}, εκτός από
τις δομές στο κείμενο που σημαδεύουν την αρχή του κώδικα.
Ο λεκτικός αναλυτής πρέπει να μπορεί να αναγνωρίσει τις δομές αυτές, ώστε να
σταματήσει την περαιτέρω ανάλυση του κειμένου.

Οι δομές που αναγνωρίζει ο αναλυτής είναι:
\begin{itemize}
    \item \textless \% σημαδεύει την αρχή του κώδικα της \textlatin{ASP}.
    Ο αναλυτής σταματά την ανάλυση του κειμένου που ακολουθεί.
    \item \textlatin{\textless script language="lang" runat="Server">} Ο κώδικας
    που ακολουθεί είναι στην γλώσσα που καθορίζεται από την τιμή της ιδιότητας
    \textlatin{language}. Εάν η ιδιότητα \textlatin{runat} δεν υπάρχει ή δεν
    έχει την τιμή \textlatin{Server}, τότε ότι ακολουθεί θεωρείται απλό κείμενο
    και ο λεκτικός αναλυτής εξακολουθεί την ανάλυση του κειμένου. Πρέπει να
    επισημάνουμε πως η παραπάνω δομή δεν σημαίνει πως το κείμενο είναι κώδικας
    \textlatin{HTML}. Καθίσταται φανερό ωστόσο πως ο αναλυτής πρέπει να κατανοεί
    κώδικα \textlatin{HTML} ώστε να μπορεί να διακρίνει πότε ξεκινά κώδικας της
    \textlatin{ASP} και να σταματήσει την περαιτέρω ανάλυση του κειμένου.
    \item \textlatin{\textless \%@language="lang"\%>} ορίζει την γλώσσα της
    σελίδας.
    \item απλό κείμενο που μπορεί να είναι \textlatin{HTML}, \textlatin{XML}
    ή οτιδήποτε άλλο.
\end{itemize}


\subsubsection{Κοινά στοιχεία λεκτικών αναλυτών της \textlatin{JScript}
και \textlatin{VbScript}}
Το \textlatin{Antlr} προσφέρει έναν εύκολο τρόπο ορισμού λέξεων κλειδιών.
Δυστυχώς ο μηχανισμός αυτός δεν μπορεί να αξιοποιηθεί λόγω της ύπαρξης των
\textlatin{ActiveX}. Ένα \textlatin{ActiveX} μπορεί να έχει μεθόδους ή ιδιότητες
με όνομα ίδιο με κάποια λέξη κλειδί της \textlatin{JScript} ή
\textlatin{VbScript}. Για παράδειγμα οι εκφράσεις \textlatin{activeX.dim} και
\textlatin{activeX.var} είναι σωστές εάν υποθέσουμε πως το \textlatin{activeX}
αναφέρεται σε κάποιο αντικείμενο \textlatin{ActiveX}. Το πρόβλημα είναι πως η
λέξη \textlatin{dim} έχει ειδική σημασία για την \textlatin{VbScript} ενώ η
\textlatin{var} για την \textlatin{JScript}. Εάν αξιοποιούσαμε τον μηχανισμό
του \textlatin{Antlr} για την αναγνώριση των λέξεων κλειδιών, τότε οι
αντίστοιχοι αναλυτές θα ερμήνευαν λανθασμένα τις εκφράσεις που αναφέραμε. Το
πρόβλημα επιλύεται εάν υιοθετήσουμε την παρακάτω στρατηγική. Οι λέξεις που
έπονται της τελείας, θεωρούνται πάντα ως ιδιότητες κλάσεων, και δεν εξετάζεται
εάν συμπίπτουν με κάποια δεσμευμένη λέξη της γλώσσας που αναγνωρίζει ο αναλυτής.
Οι δεσμευμένες λέξεις αποθηκεύονται σε μία δομή πίνακα \textlatin{(HashTable)}
όπου το κλειδί είναι η δεσμευμένη λέξη, και η τιμή που αντιστοιχεί στο κλειδί
είναι ένας αριθμός που χαρακτηρίζει το \textlatin{token} της δεσμευμένης λέξης.

Όταν οι λεκτικοί αναλυτές αναγνωρίσουν μία λέξη που δεν έπεται της τελείας, τότε
εξετάζουν εάν η λέξη υπάρχει στον πίνακα των δεσμευμένων λέξεων. Εάν υπάρχει,
οι λεκτικοί αναλυτές παράγουν ένα \textlatin{token} με τύπο τον αριθμό που
αντιστοιχεί στο κλειδί στον πίνακα, και κείμενο την λέξη που αναγνωρίστηκε.

Οι χαρακτήρες που δεν έχουν κάποια αξία για τα επόμενα στάδια ανάλυσης, όπως το
κενό \textlatin{(space)} και το \textlatin{tab}, απορρίπτονται.

Αν και τα σχόλια ορίζονται διαφορετικά σε κάθε γλώσσα, και οι δύο λεκτικοί
αναλυτές τα απορρίπτουν μόλις τα αναγνωρίσουν. Θα ήταν θεμιτό τα σχόλια
να διατηρούνται, αποβάλλονται όμως για να διευκολυνθεί το έργο στα ανώτερα
επίπεδα ανάλυσης.

\subsubsection{\textlatin{JScript}}
Ο λεκτικός αναλυτής της \textlatin{JScript} αναγνωρίζει τμήματα της
\textlatin{ASP} σελίδας γραμμένα σε \textlatin{JScript}. Αναγνωρίζει
τελεστές, λέξεις κλειδιά, και άλλους χαρακτήρες με ειδική σημασία όπως το \{, (
και άλλους.

Σε πολλές γλώσσες υπάρχει ένας ειδικός χαρακτήρας που χρησιμοποιείται για να
σημαδεύεται το σημείο όπου τελειώνει μια δήλωση \textlatin{(statement)}.
Στην \textlatin{JScript} υπάρχει επίσης ο χαρακτήρας αυτός, και είναι το ';'.
Ωστόσο, είναι επιτρεπτό ο χαρακτήρας να παραλειφθεί και τότε το τέλος της
δήλωσης συμπίπτει με το τέλος της γραμμής. Συνάμα, κενές γραμμές μπορούν να
παρεμβάλλονται στο σώμα μίας δήλωσης, αλλά τότε υποχρεωτικά πρέπει να
χρησιμοποιηθεί ο ειδικός χαρακτήρας τερματισμού δήλωσης. Είναι φανερό πως ο
χαρακτήρας τερματισμού γραμμής, γενικά πρέπει να αποβάλλεται, αλλά σε ειδικές
περιπτώσεις είναι χρήσιμο να διατηρηθεί για τα επόμενα στάδια ανάλυσης.

Ο λεκτικός αναλυτής, για να διευκολύνει το έργο τον ανώτερων σταδίων
επεξεργασίας, κατασκευάζει το ίδιο τύπο \textlatin{token} όταν αναγνωρίσει τον
χαρακτήρα τερματισμού δηλώσεων και τον χαρακτήρα τερματισμού γραμμής. Επιπλέον,
για να αποφευχθεί η δημιουργία \textlatin{token} χωρίς συντακτική αξία, οι
χαρακτήρες τερματισμού γραμμής απορρίπτονται, όταν είναι βέβαιον πως είναι
πλεονάζοντες χαρακτήρες δίχως αξία για την συντακτική ανάλυση. Λόγω της
εξαιρετικά μυωπικής γνώσης που έχουν οι λεκτικοί αναλυτές, η αποβολή όλων
των πλεοναζόντων κενών γραμμών δεν είναι εφικτή. Ορισμένα \textlatin{token}
χωρίς συντακτική αξία διατηρούνται, οπότε είναι έργο της συντακτικής ανάλυσης
να αποβάλει αυτά τα \textlatin{token}.


\subsubsection{\textlatin{VbScript}}
Ο λεκτικός αναλυτής της \textlatin{VBScript}, όπως και εκείνος της
\textlatin{JScript}, αναγνωρίζει τελεστές, λέξεις κλειδιά,
και άλλους χαρακτήρες με ειδική σημασία όπως το \_, ( και άλλους.

Σε αντίθεση με την \textlatin{JScript}, στην \textlatin{VBScript} το τέλος της
γραμμής έχει πάντα συντακτική αξία, και τερματίζει μία δήλωση. Σε αυτόν τον
κανόνα υπάρχει μονάχα μία εξαίρεση. Μία δήλωση μπορεί να συνεχίζεται στην
επόμενη γραμμή εφόσον ο τελευταίος χαρακτήρας (αγνοώντας τα κενά ή τα
\textlatin{tab}) είναι το \_, οπότε το τέλος γραμμής αποβάλλεται.

Μία άλλη σημαντική διαφορά ανάμεσα στις δύο γλώσσες, είναι το ότι στην
\textlatin{JScript} έχει σημασία εάν οι λέξεις-κλειδιά και τα αναγνωριστικά
\textlatin{(identifiers)} είναι με πεζά γράμματα ή με κεφαλαία, ενώ για την
\textlatin{VBScript} δεν  έχει σημασία. Για την διευκόλυνση του συντακτικού
αναλυτή, ο λεκτικός αναλυτής αναλαμβάνει να παρουσιάσει τα αναγνωριστικά πάντα
με τον ίδιο τρόπο γραφής, σαν να επρόκειτο για γλώσσα όπου υπάρχει η
διαφοροποίηση μεταξύ πεζών και κεφαλαίων. Επιπλέον, στην \textlatin{PHP} όπως
και στην \textlatin{JScript}, τα αναγνωριστικά διαφοροποιούνται εάν περιέχουν
μικρά ή κεφαλαία. Η μεταβλητή \textlatin{myVar} είναι διαφορετική από την
μεταβλητή \textlatin{myvar}. Επιβάλλεται η γραφή των μεταβλητών της
\textlatin{VBScript} πάντα με τον ίδιο τρόπο, διότι διαφορετικά η μετάφραση
θα αποτύγχανε.

Ένας τρόπος για να επιτευχθεί ο παραπάνω στόχος θα ήταν η μετατροπή των
αναγνωριστικών σε λέξεις που περιέχουν μόνο πεζά ή μόνο κεφαλαία γράμματα. Το
πρόβλημα με την επιλογή των κεφαλαίων γραμμάτων είναι ότι κατά σύμβαση,
συνηθίζεται να γράφονται έτσι οι σταθερές \textlatin{(constants)} που περιέχει
το πρόγραμμα. Επίσης, από πολλούς θεωρείται αντιαισθητικό να γράφονται οι
μεταβλητές με κεφαλαία. Υπάρχει άλλο ένα πρόβλημα κοινό και για τα κεφαλαία και
για τα πεζά. Συχνά οι μεταβλητές περιέχουν δύο ή παραπάνω λέξεις στο όνομά τους,
όπου κάθε νέα λέξη διαφοροποιείται από την προηγούμενη έχοντας το πρώτο της
γράμμα κεφαλαίο (για παράδειγμα \textlatin{myId}). Αν αλλάζαμε το όνομα της
μεταβλητής σε \textlatin{myid} ή \textlatin{MYID}, τότε οι λέξεις δεν ξεχωρίζουν
πια. Τέλος, ένα πρόγραμμα όπου τα ονόματα των μεταβλητών έχουν αλλάξει, θα
φαινόταν ξένο στον προγραμματιστή που το έγραψε.

Για να αποφύγουμε τα προβλήματα που αναφέραμε παραπάνω, ακολουθήσαμε έναν άλλον
τρόπο. Όλα τα ονόματα των μεταβλητών που αναγνωρίζει ο λεκτικός αναλυτής,
αποθηκεύονται σε μία λίστα. Κάθε φορά που αναγνωρίζεται ένα άλλο αναγνωριστικό,
ο λεκτικός αναλυτής αναζητά στην λίστα, εάν υπάρχει κάποιο αναγνωριστικό με το
ίδιο όνομα, χωρίς να λαμβάνεται υπόψιν η διαφορά κεφαλών και πεζών.
Εάν το βρει, τότε εξομοιώνει το όνομα του αναγνωριστικού που βρήκε με αυτό της
λίστας, διαφορετικά προσθέτει το αναγνωριστικό στην λίστα.

Ας δώσουμε ένα παράδειγμα:\\\textlatin{
myId = 20\\
mYid = 30\\
MYID = 40\\
anOtherVar = 10\\}
Αν εξετάζαμε την έξοδο του λεκτικού αναλυτή, θα είχαμε την εντύπωση πως ο
κώδικας που αναλύθηκε είναι\\\textlatin{
myId = 20\\
myId = 30\\
myId = 40\\
anOtherVar = 10\\}
Η λίστα που διατηρεί ο αναλυτής περιέχει τα στοιχεία \textlatin{myId} και
\textlatin{anOtherVar}.


\subsection{Σύνθεση ροής \textlatin{token}}
Όπως έχουμε ήδη αναφέρει, οι σελίδες \textlatin{ASP} ενδέχεται να περιέχουν
απλό κείμενο, κώδικα \textlatin{JScript} και \textlatin{VBScript}. Κάθε
τμήμα της σελίδας, πρέπει να αναλυθεί από τον κατάλληλο λεκτικό αναλυτή, και
απαιτείται ένας μηχανισμός που θα αποφασίζει ποιος λεκτικός αναλυτής θα
ενεργοποιείται κάθε φορά που ένα τμήμα σε διαφορετική γλώσσα από το προηγούμενο
ξεκινά. Κάθε λεκτικός αναλυτής παράγει μία ροή από \textlatin{token}. Οι
επιμέρους ροές \textlatin{token} πρέπει να συντμηθούν σε μία και μόνο ροή,
ώστε να αναλυθεί από τους συντακτικούς αναλυτές.

\subsubsection{\textlatin{AspStreamSelector}}
Το \textlatin{AspStreamSelector} είναι μία κλάση που συνθέτει τις ροές από
\textlatin{token} και ενεργοποιεί τους λεκτικούς αναλυτές κατά το δοκούν. Ο
πρώτος λεκτικός αναλυτής που ενεργοποιείται είναι ο \textlatin{HtmlLexer}. Εάν
το αρχείο προς ανάλυση είναι αυτόνομο, δεν αναλύεται δηλαδή επειδή απαιτείται
για την ανάλυση κάποιου άλλου αρχείου, γίνεται προσπάθεια προσδιορισμού της
γλώσσας της σελίδας. Να υπενθυμίσουμε πως η γλώσσα της σελίδας καθορίζεται από
την εντολή \textlatin{\textless \%@Language="lang"\%>} όπου \textlatin{lang}
είναι η γλώσσα. Ο λόγος που το \textlatin{AspStreamSelector} δεν επιχειρεί να
προσδιορίσει την γλώσσα για αρχεία βοηθητικά του κυρίως αρχείου, είναι επειδή τα
αρχεία που συμπεριλαμβάνονται από κάποιο άλλο, οφείλουν να είναι στην ίδια
γλώσσα με εκείνο που τα συμπεριέλαβε.

Τα \textlatin{token} που παράγει ο λεκτικός αναλυτής της \textlatin{HTML}
διακρίνονται σε δύο κατηγορίες, τα \textlatin{token} που έχουν συντακτική αξία
και εκείνα που χρησιμοποιεί το \textlatin{AspStreamSelector} για να αποφασίσει
ποιος θα είναι ο επόμενος λεκτικός αναλυτής που θα αναλάβει την επεξεργασία του
εναπομείναντος κειμένου.

Στην πρώτη κατηγορία ανήκουν τα παρακάτω \textlatin{token}:
\begin{itemize}
    \item \textlatin{HTML} περιέχει το στατικό κείμενο που προηγείται, έπεται
    ή παρεμβάλλεται στον κώδικα. Όταν ο \textlatin{HtmlLexer} παρέχει
    περισσότερα από ένα \textlatin{token} αυτού του τύπου στη σειρά, τότε τα
    \textlatin{token} συμπτύσσονται σε ένα του οποίου το κείμενο είναι η
    συνάθροιση των κειμένων  των \textlatin{token} που ελήφθησαν. Στην περίπτωση
    που δοθεί ένα μόνο \textlatin{token} και το κείμενο περιέχει μόνο κενούς
    χαρακτήρες ή έναν χαρακτήρα αλλαγής γραμμής, τότε το \textlatin{token}
    απορρίπτεται.
    \item \textlatin{INCLUDE} δείχνει σε ένα αρχείο που απαιτείται για την
    ανάλυση του τρέχοντος αρχείου.
\end{itemize}

Για να μπορέσουν οι συντακτικοί αναλυτές της \textlatin{VBScript} και
της \textlatin{JScript} να χρησιμοποιήσουν τα \textlatin{token} του
\textlatin{HtmlLexer}, ο κωδικός αριθμός του \textlatin{token} πρέπει να αλλάξει
στον αντίστοιχο \textlatin{token} που αναγνωρίζει ο αναλυτής. Για παράδειγμα, ο
κωδικός αριθμός για το \textlatin{token} \textlatin{HTML} είναι 56 στην
\textlatin{JScript} και 81 στην \textlatin{VBScript}. Εάν το
\textlatin{token} δεν έχει το σωστό κωδικό για το συντακτικό αναλυτή που θα
το επεξεργαστεί, η συντακτική ανάλυση θα αποτύχει τελείως ή θα είναι εσφαλμένη.

Τα \textlatin{token} της δεύτερης κατηγορίες, όπως αναφέρθηκε, εξυπηρετούν στην
διαχείρισή της σειράς με την οποία ενεργοποιούνται οι λεκτικοί αναλυτές. Το
\textlatin{AspStreamSelector}, αφού λάβει αποφάσεις βασιζόμενος σε αυτά τα
\textlatin{token}, τα απορρίπτει διότι δεν έχουν συντακτική αξία.

Μία άλλη λειτουργία που εκτελεί το \textlatin{AspStreamSelector}, είναι η
εισαγωγή εικονικών \textlatin{token}, \textlatin{token} δηλαδή που δεν
προήλθαν από κανέναν λεκτικό αναλυτή. Η εισαγωγή τους επιβάλλεται από ανάγκες
της συντακτικής ανάλυσης.

Καθένας από τους δύο συντακτικούς αναλυτές, αναμένει
ότι το τελευταίο \textlatin{token} που θα λάβει θα είναι το \textlatin{EOF} που
σημαδεύει το τέλος εισόδου. Στην περίπτωση που οι δύο γλώσσες εναλλάσσονται
στο ίδιο αρχείο εισόδου, είναι προφανές πως η είσοδος που προορίζεται για τον
έναν από τους αναλυτές, θα τελειώσει στο σημείο όπου εναλλάσσονται οι γλώσσες,
ενώ αντίθετα το περιεχόμενο του αρχείου δεν θα έχει τελειώσει.
Για να λύσει το πρόβλημα, το \textlatin{AspStreamSelector} εισάγει ένα
εικονικό \textlatin{token} του τύπου \textlatin{EOF},
δίνοντας την ψευδαίσθηση του τέλους εισόδου στον συντακτικό αναλυτή.

Ένα άλλο παράδειγμα είναι το \textlatin{token} \textlatin{EQ\_HTML}. To
\textlatin{token} κατασκευάζεται κάθε φορά που στο αρχείο εισόδου υπάρχει η
έκφραση \textless \%=, που σημαίνει ότι η έκφραση που έπεται θα πρέπει να σταλεί
στον επισκέπτη της σελίδας ως συμβολοσειρά. Είναι ουσιαστικά συντομογραφία της
έκφρασης \textlatin{Response.write(someExpr)} που επιτελεί τον ίδιο σκοπό. Το
\textlatin{token} \textlatin{EQ\_HTML} προκύπτει από την σύνθεση δύο
\textlatin{token}, του \textlatin{ASP\_START} με κείμενο \textless \% που
παράγεται από το \textlatin{HtmlLexer}, και του \textlatin{token} που συμβολίζει
τον τελεστή ανάθεσης τιμής ή ισότητας (ανάλογα με την γλώσσα), που παράγεται
είτε από το \textlatin{JsLexer} ή από το \textlatin{VbsLexer}, ανάλογα με το
ποιος από τους δύο λεκτικούς αναλυτές είναι ενεργός. Τα δύο \textlatin{token},
\textlatin{ASP\_START} και τελεστής ισότητας, αντικαθιστώνται με το
\textlatin{EQ\_HTML}. Εάν δεν λάμβανε χώρα η αντικατάσταση, οι γλώσσες που θα
αναγνώριζαν οι συντακτικοί αναλυτές της \textlatin{JScript} και
\textlatin{VbScript} θα ήταν διφορούμενες, οπότε δεν θα μπορούσε να γίνει
συντακτική ανάλυση σε αυτές. Επιπρόσθετα, ο τελεστής \textless\%= δεν είναι στην
πραγματικότητα τελεστής των δύο γλωσσών, αλλά ένα τέχνασμα για την διευκόλυνση
του προγραμματιστή.

\subsection{Συντακτικοί Αναλυτές}
Οι συντακτικοί αναλυτές της \textlatin{JScript} και \textlatin{VBScript}
μετατρέπουν την ροή από \textlatin{token} σε δέντρο \textlatin{AST}. Κάθε
συντακτικός αναλυτής αποτελείται από ένα σύνολο κανόνων που ορίζουν την
σειρά των \textlatin{token} που αναγνωρίζει ο κανόνας. Ορισμένα
\textlatin{token} μπορεί να είναι προαιρετικά, να επαναλαμβάνονται πολλές φορές
ή να απαιτείται η ύπαρξη τους για να επιτύχει η αναγνώριση της σειράς ως έγκυρη
συντακτική δομή της γλώσσας. Επιπλέον, ένας κανόνας μπορεί να βασίζεται σε
άλλους κανόνες για κάποιο τμήμα της αναγνώρισης που με την σειρά τους βασίζονται
σε άλλους κανόνες και ούτω καθεξής.

Ένα βασικό έργο για την επιτυχή αναγνώριση
της σειράς των \textlatin{token} είναι η δήλωση των κανόνων που αναγνωρίζουν
τις εκφράσεις της κάθε γλώσσας. Οι εκφράσεις είναι εξ ορισμού αναδρομικές και
έχουν προκαθορισμένους κανόνες προτεραιοτήτων. Η αναδρομικότητα και οι κανόνες
προτεραιοτήτων κάνουν δύσκολη την αναγνώριση των εκφράσεων.
Όμως αφού υλοποιηθούν οι παραπάνω κανόνες, το έργο που απομένει για να
ολοκληρωθεί ο συντακτικός αναλυτής είναι συγκριτικά μικρό. Οι εκφράσεις
αποτελούνται από αριθμούς, αλφαριθμητικά και αναγνωριστικά που συνδέονται μεταξύ
τους με τελεστές. Οι τελεστές δεν είναι ισότιμοι διότι υπάρχουν κανόνες
προτεραιοτήτων που καθορίζουν την εκτίμηση της τιμής μιας έκφρασης. Οι κανόνες
προτεραιότητας μπορούν να παρακαμφθούν με την κατάλληλη χρήση ομαδοποιήσεων των
εκφράσεων μέσω παρενθέσεων.

Παρακάτω θα δείξουμε αναλυτικά τις δομές που αναγνωρίζουν οι συντακτικοί
αναλυτές της \textlatin{JScript} και \textlatin{VbScript} και την μορφή των
δέντρων που κατασκευάζουν. Επίσης θα αναφερθούμε σε δομές δεδομένων που
χρησιμοποιούν οι συντακτικοί αναλυτές για την αποθήκευση επιπλέον πληροφοριών
που αξιοποιούνται από τους μεταφραστές κατά την διαδικασία μετατροπής των
\textlatin{AST} δέντρων σε δέντρα που αναπαριστούν \textlatin{PHP} κώδικα. Όταν
θα αναφερόμαστε σε δομές δέντρων θα χρησιμοποιήσουμε την σημασιολογία της
\textlatin{Lisp} \cite{bib:lisp} για την περιγραφή. Για παράδειγμα η έκφραση
\textlatin{(a (b c))} σημαίνει πως το δέντρο έχει για ρίζα το κόμβο \textlatin{a}
, του οποίου παιδί είναι ο κόμβος \textlatin{b} που έχει για παιδί τον κόμβο
\textlatin{c}.

\subsubsection{Συντακτικός αναλυτής της \textlatin{JScript}}
Όπως αναφέραμε παραπάνω, η υλοποίηση των κανόνων που αναγνωρίζουν τις εκφράσεις
αποτελούν βασικό μέρος του συντακτικού αναλυτή, οπότε θα ξεκινήσουμε με την
περιγραφή αυτών των κανόνων. Οι κανόνες είναι αναδρομικοί και καλούνται με
τέτοια σειρά ώστε να ακολουθούν τους κανόνες προτεραιότητας που ορίζει η γλώσσα
για τους τελεστές. Κάθε κανόνας αναγνωρίζει έναν τελεστή και τις υποεκφράσεις
που συνοδεύουν τον τελεστή. Αρχικά καλείται ο κανόνας που αναγνωρίζει τον
τελεστή με την μικρότερη προτεραιότητα. Ο κανόνας καλεί πρώτα τον αμέσως
ισχυρότερο κανόνα από την άποψη της προτεραιότητας και έπειτα επιχειρεί να
αναγνωρίσει τον δικό του τελεστή. Με αυτό τον τρόπο εξασφαλίζεται ότι οι κανόνες
προτεραιοτήτων ακολουθούνται αφού οι κανόνες που αναγνωρίζουν τελεστές με
μεγαλύτερη προτεραιότητα έχουν πρώτοι την ευκαιρία να αναγνωρίσουν την έκφραση.

Ο πρώτος κανόνας που καλείται ονομάζεται \textlatin{expression}. Ο κανόνας καλεί
τον ασθενέστερο κανόνα που αναγνωρίζει την ανάθεση τιμής. Ο κανόνας υπάρχει
διότι μόλις η έκφραση αναγνωρισθεί από τους άλλους κανόνες που καλεί,
κατασκευάζει ένα δέντρο του οποίου ρίζα θα είναι πάντα ο κόμβος
\textlatin{EXPR}. Τα δέντρα που προκύπτουν από τις εκφράσεις θα έχουν πάντα την
δομή \textlatin{(EXPR expression)}.

Η \textlatin{JScript} έχει 12 τελεστές ανάθεσης τιμής. Οι τελεστές είναι:
\begin{description}
    \item[=] θέτει στην έκφραση που βρίσκεται αριστερά του τελεστή την τιμή
    της έκφρασης που βρίσκεται δεξιά.
    \item[+=, -=, *=, =, \%=] οι τελεστές θέτουν την τιμή της έκφρασης που
    βρίσκεται αριστερά του τελεστή ίση με το άθροισμα, τη διαφορά, το γινόμενο,
    το πηλίκο ή το υπόλοιπο της διαίρεσης
    της έκφρασης στα αριστερά και της έκφρασης στα δεξιά αντίστοιχα.
    \item[\textless\textless=, \textgreater\textgreater=,
    \textgreater\textgreater\textgreater=]
    θέτει νέα τιμή στην έκφραση αφού
    πρώτα εκτελεστούν πράξεις στα \textlatin{bits} της έκφρασης.
    \item[\&=, \textbar=, \^{}=] θέτουν νέα τιμή στην έκφραση στα αριστερά αφού
    πρώτα εκτελεστούν λογικές πράξεις επί των δύο εκφράσεων.
\end{description}
Οι δώδεκα τελεστές έχουν την ίδια προτεραιότητα. Ο κανόνας ανάθεσης τιμής
καλεί πρώτα τον κανόνα αναγνώρισης λογικών εκφράσεων διότι έχει μεγαλύτερη
προτεραιότητα. Έπειτα επιχειρεί να αναγνωρίσει έναν από τους δώδεκα τελεστές. Αν
κάποιος από τους τελεστές αναγνωρισθεί, τότε ο κανόνας καλεί τον εαυτό του. Εάν
δεν αναγνωρισθεί κανένας από τους τελεστές, ο κανόνας έχει ολοκληρώσει το έργο
του. Η αναγνώριση των τελεστών είναι προαιρετική διότι ειδάλλως κάθε έκφραση θα
έπρεπε να είναι έκφραση ανάθεσης τιμής. Εάν η έκφραση προς αναγνώριση δεν είναι
έκφραση ανάθεσης τιμής, ο κανόνας που μπορεί να την αναγνωρίσει κάποια στιγμή θα
κληθεί.

Ο αμέσως ισχυρότερος κανόνας είναι εκείνος που αναγνωρίζει εκφράσεις του τύπου
\protect{\textlatin{boolexpr ? expressionA : expressionB}}. Η έκφραση
αποτελείται από τρεις υποεκφράσεις και δύο τελεστές. Η πρώτη έκφραση πρέπει να
έχει τιμή αληθή ή ψευδή. Εάν η τιμή της πρώτης έκφρασης είναι αληθής, τότε
εκτιμάτε η τιμή της δεύτερης έκφρασης, διαφορετικά εκτιμάτε η τιμή της τρίτης.
Ο κανόνας αρχικά καλεί τον κανόνα αναγνώρισης λογικών εκφράσεων με τον τελεστή
διάζευξης \textlatin{(or)} και έπειτα επιχειρεί να αναγνωρίσει τους δύο τελεστές
και τις υποεκφράσεις τους.

Ο κανόνας λογικής διάζευξης καλεί τον κανόνα λογικής σύζευξης \textlatin{(and)}
και επιχειρεί να αναγνωρίσει τον τελεστή \textlatin{(or)}. Εάν ο τελεστής
αναγνωρισθεί, τότε καλείται και πάλι ο κανόνας λογικής σύζευξης. Η ίδια
διαδικασία ακολουθείτε για τους κανόνες λογικής σύζευξης, δυαδικής διάζευξης,
αποκλειστικής διάζευξης \textlatin{(xor)} και δυαδικής σύζευξης.

Ο επόμενος κανόνας αναγνωρίζει τους τελεστές ελέγχου ισότητας και ταυτότητας.
Οι τελεστές ελέγχου ισότητας είναι οι ==, != οι οποίοι εξετάζουν αν οι εκφράσεις
εκατέρωθεν των τελεστών είναι ίσες ή αν είναι άνισες αντίστοιχα. Οι τελεστές
ελέγχου ταυτότητας εξετάζουν αν δύο αναγνωριστικά αναφέρονται στην ίδια θέση
μνήμης. Η τακτική που ακολουθεί ο κανόνας δεν διαφέρει από όσους αναφέραμε
παραπάνω.

Ακολουθεί ο κανόνας που αναγνωρίζει τελεστές σύγκρισης τιμών που είναι οι:
\begin{description}
    \item[\textless]: ελέγχει εάν η τιμή της έκφρασης στα αριστερά είναι
    μικρότερη από εκείνης στα δεξιά του τελεστή.
    \item[\textgreater]: ελέγχει εάν η τιμή της έκφρασης στα αριστερά είναι
    μεγαλύτερη από εκείνης στα δεξιά του τελεστή.
    \item[\textless=]: ελέγχει εάν η τιμή της έκφρασης στα αριστερά είναι
    μικρότερη ή ίση με εκείνης στα δεξιά του τελεστή.
    \item[\textgreater=]: ελέγχει εάν η τιμή της έκφρασης στα αριστερά είναι ή
    ίση με εκείνης στα δεξιά του τελεστή.
    \item[\textlatin{instanceof}]: εξετάζει εάν ένα αντικείμενο έχει
    κατασκευαστεί από κάποια κλάση.
\end{description}

Αμέσως μετά, βρίσκονται οι τελεστές που εκτελούν πράξεις επί των δυαδικών ψηφίων
των μεταβλητών \textlatin{(bit operation)}. Οι τελεστές παρατίθενται παρακάτω:
\begin{description}
    \item[\textless \textless] προκαλεί ολίσθηση προς τα αριστερά των δυαδικών
    ψηφίων της τιμής της μεταβλητής
    \item[\textgreater\textgreater] προκαλεί ολίσθηση προς τα δεξιά.
    \item[\textgreater\textgreater\textgreater\textgreater] προκαλεί ολίσθηση
    προς τα δεξιά ενώ διατηρεί το πρόσημο της αρχικής τιμής.
\end{description}

Μετά τους τελεστές δυαδικών πράξεων, ακολουθούν οι τελεστές άθροισης και
αφαίρεσης, και στη συνέχεια οι τελεστές πολλαπλασιασμού, διαίρεσης και
ακεραίου υπολοίπου.

Παραπάνω παραθέσαμε τους τελεστές που δρουν επί δύο εκφράσεων ή δυαδικούς
τελεστές. Παρακάτω θα δείξουμε τους μονήρεις τελεστές, τελεστές που δρουν επί
μίας μόνο έκφρασης, με την σειρά προτεραιότητας τους. Οι τελεστές είναι:
\begin{description}
    \item[++] αυξάνει κατά ένα την τιμή της έκφρασης.
    \item[\texttt{- -}] μειώνει κατά ένα την τιμή της έκφρασης.
    \item[-] το πρόσημο της έκφρασης είναι αρνητικό.
    \item[+] το πρόσημο της έκφρασης είναι θετικό.
    \item[\~{}] αντιστρέφει τα δυαδικά ψηφία της έκφρασης.
    \item[!] είναι ο τελεστής λογικής άρνησης. Εάν η τιμή της έκφρασης είναι
    αληθής, τότε θα γίνει ψευδής και αντιστρόφως.
    \item[\textlatin{delete}] διαγράφει την μεταβλητή, και αποδεσμεύει το χώρο
    που κατείχε στην μνήμη.
    \item[\textlatin{typeof}] επιστρέφει το όνομα του τύπου μίας έκφρασης.
    \item[\textlatin{new}] κατασκευάζει ένα αντικείμενο κάποιας κλάσης.
\end{description}

Στην ιεραρχία προτεραιοτήτων ακολουθεί ο τελεστής αρχικοποίησης πινάκων. Ας
δώσουμε ένα παράδειγμα για να γίνει κατανοητός ο ρόλος και η συντακτική δομή του
τελεστή. Η έκφραση \textlatin{a = [12, 3, true, "string"]} αρχικοποιεί έναν
πίνακα που τα στοιχεία του είναι το 12 το 13 το \ldots. Η διαδικασία αναγνώρισης
της έκφρασης απαιτεί την αναγνώριση του \textlatin{token} [, έπειτα την
αναγνώριση μίας σειράς εκφράσεων που διαχωρίζονται από κόμματα, και τέλος το
\textlatin{token} ].

Οι εκφράσεις μπορεί να περιέχουν το τελεστή '.' που σηματοδοτεί την αίτηση
ανάκτησης ενός μέλους μίας κλάσης, όπως για παράδειγμα η έκφραση
\textlatin{"string".length} που καλεί την ιδιότητα \textlatin{length} από την
κλάση \textlatin{String}. Έχουμε δύο επιπλέον τελεστές, τον τελεστή πρόσβασης
στοιχείου ενός πίνακα (για παράδειγμα \textlatin{a[0]}) και τον τελεστή κλήσης
μεθόδου (παράδειγμα \textlatin{method(arg)}).

Τέλος έχουμε τις βασικές εκφράσεις που δεν διασπώνται σε επί μέρους τμήματα από
τελεστές. Οι βασικές εκφράσεις είναι οι παρακάτω:
\begin{itemize}
    \item Ονόματα μεταβλητών.
    \item Αριθμοί
    \item Συμβολοσειρές
    \item Οι λογικές τιμές \textlatin{true} και \textlatin{false}
    \item Η τιμή \textlatin{null}
    \item Η κενή τιμή \textlatin{void}
    \item Η ακαθόριστη τιμή \textlatin{undefined}
    \item Κανονικές εκφράσεις
    \item Η ειδική μεταβλητή \textlatin{this} που αναφέρεται στο τρέχον
    αντικείμενο μίας κλάσης.
    \item Τύποι αντικειμένων όπως το \textlatin{Array, Object,} \ldots
    \item Αυτόνομες εκφράσεις που περικλείονται σε παρενθέσεις
    \item Ανώνυμες συναρτήσεις
\end{itemize}

Εκτός από εκφράσεις, η \textlatin{JScript} περιέχει και άλλες συντακτικές
δομές που εξυπηρετούν στον έλεγχο ροής, σχηματισμό βρόχων και άλλα. Παρακάτω θα
αναλύσουμε τις συντακτικές δομές της \textlatin{JScript}.
\begin{description}
    \item[\textlatin{if/else}] Η εντολή χρησιμοποιείται για έλεγχο ροής.
    Η δομή της είναι:\\
    \textlatin{if(} λογική έκφραση ) εντολές και εκφράσεις\\
    \textlatin{else} εντολές και εκφράσεις\\
    Εάν η λογική έκφραση έχει αληθή τιμή, τότε οι εντολές και εκφράσεις που
    ακολουθούν εκτελούνται, διαφορετικά εκτελούνται οι εντολές και εκφράσεις της
    εντολής \textlatin{else}. Η εντολή \textlatin{else} είναι προαιρετική.
    Το δέντρο που παράγεται από την εντολή έχει την μορφή:\\
    \includegraphics{if}
    \item[\textlatin{switch}] Αποτελεί άλλη μία δομή για τον έλεγχο ροής.
    Η δομή της είναι:\\
    \textlatin{switch (} έκφραση )\\
    \textlatin{case} τιμή εντολές\\
    \textlatin{default} εντολές\\
    Η εντολή εξετάζει ποια από τις τιμές των \textlatin{case} εντολών ισούται με
    την έκφραση και εκτελεί τις εντολές που έπονται της αντίστοιχης
    \textlatin{case} εντολής. Εάν καμία από τις \textlatin{case} εντολές δεν
    έχει τιμή ίση με την έκφραση, τότε εκτελούνται οι εντολές της
    \textlatin{default}, εφόσον υπάρχει.
    Το δέντρο που παράγεται από την εντολή έχει την μορφή:\\
    \includegraphics{switch}
    \item[\textlatin{for}] Η δομή χρησιμεύει για τον καθορισμό βρόχων.
    Η μορφή της είναι:\\
    \textlatin{for (} μεταβλητή όπου αποθηκεύεται το πλήθος των βρόχων που
    έχουν εκτελεστεί; συνθήκη που ορίζει πότε θα τερματιστεί ο βρόχος; έκφραση
    που αλλάζει την τιμή της μεταβλητής που αποθηκεύει το πλήθος των βρόχων)\\
    εντολές\\
    Κάποια, ή και τα τρία τμήματα της εντολής \textit{\textlatin{for}} μπορούν
    να παραλειφθούν. Για παράδειγμα, η εντολή \textlatin{for (;;)} είναι
    συντακτικά σωστή, και ορίζει έναν ατέρμονα βρόχο.
    Το δέντρο που παράγεται από την εντολή έχει την μορφή:\\
    \includegraphics{for}
    \includegraphics{for2}
    Μία άλλη μορφή της δομής \textlatin{for} χρησιμοποιείται για πρόσβαση των
    ιδιοτήτων ενός αντικειμένου. Η μορφή της εναλλακτικής σύνταξής είναι:\\
    \textlatin{for (} μεταβλητή \textlatin{in} μεταβλητή όπου έχει αποθηκευτεί
    ένα αντικείμενο)\\εντολές.
    Το δέντρο που παράγεται από την εντολή με την δεύτερη σύνατξη έχει την
    μορφή:\\
    \includegraphics{forin}
    \item[\textlatin{while}] Είναι άλλη μία εντολή σχηματισμού βρόχων.
    Η σύνταξη της εντολής είναι:\\\textlatin{while (} λογική έκφραση )\\ εντολές
    \item[\textlatin{do}] Επίσης ορίζει βρόχους. Η σύνταξη της είναι:\\
    \textlatin{do} εντολές \\\textlatin{while (} λογική έκφραση).
    Το δέντρο που παράγεται από την εντολή έχει την μορφή:\\
    \includegraphics{do}
    \item[\textlatin{try/catch/finally}] Η εντολή δίνει την δυνατότητα να
    εκτελεστούν άλλες εντολές που ενδέχεται να προκαλέσουν κάποιο σφάλμα κατά
    την εκτέλεσή τους, και να ληφθούν μέτρα σε μία τέτοια περίπτωση.
    Η σύνταξη της εντολής είναι:\\\textlatin{try} εντολές \\\textlatin{catch (}
    μεταβλητή όπου αποθηκεύονται πληροφορίες για τα αίτια του σφάλματος)
    εντολές\\ \textlatin{finally} εντολές που εκτελούνται σε κάθε περίπτωση
    (είτε υπήρξε σφάλμα, είτε όχι)
    Το δέντρο που παράγεται από την εντολή έχει την μορφή:\\
    \includegraphics{try}
    \item[\textlatin{with}] Διευκολύνει στην πρόσβαση μεθόδων και ιδιοτήτων
    μίας κλάσης. Οι εντολές που περιέχονται στην \textlatin{with} δεν χρειάζεται
    να αναφέρονται ρητά στα μέλη της κλάσης (για παράδειγμα
    \textlatin{someMethod()} αντί \textlatin{someObject.someMethod()})
    παρακάμπτοντας την ανάγκη γραφής του ονόματος της μεταβλητής που περιέχει το
    αντικείμενο της κλάσης. Η σύνταξη της εντολής είναι:\\\textlatin{with (}
    μεταβλητή που περιέχει ένα αντικείμενο)\\εντολές\\
    Το δέντρο που παράγεται από την εντολή έχει την μορφή:\\
    \includegraphics{with}
    \item[\textlatin{function}] Μέσω της εντολής, ορίζονται συναρτήσεις του
    χρήστη. Η σύνταξη της εντολής είναι:\\\textlatin{function} όνομα συνάρτησης
    (ονόματα παραμέτρων) εντολές\\
    Το δέντρο που παράγεται από την εντολή έχει την μορφή:\\
    \includegraphics{function}
\end{description}

Τέλος, υπάρχουν και οι εντολές:\\
\begin{itemize}
    \item \textlatin{var}
    \item \textlatin{include}
    \item \textlatin{break}
    \item \textlatin{continue}
    \item \textlatin{return}
    \item \textlatin{throw}
\end{itemize}
Οι παραπάνω εντολές δεν παρουσιάζουν ενδιαφέρον από συντακτική σκοπιά.


\subsubsection{Συντακτικός αναλυτής της \textlatin{VbScript}}
Ο χειρισμός των εκφράσεων της \term{VbScript}, δεν διαφέρει από εκείνον της
\term{JScript}. Η \term{VbScript} παρουσιάζει μία επιπλέον δυσκολία διότι
ο τελεστής ανάθεσης τιμής είναι ο ίδιος με εκείνο του ελέγχου ισότητας. Χάριν
συντομίας παραλείπουμε την περιγραφή των κανόνων που αναγνωρίζουν τις εκφράσεις.
Παρακάτω περιγράφονται οι συντακτικές δομές της \term{VbScript} και η μορφή των
δέντρων που κατασκευάζει ο συντακτικός αναλυτής της.
\begin{description}
    \item[\textlatin{On Error}] Η εντολή παρέχει την δυνατότητα εκτέλεσης
    τμημάτων του κώδικα, σε περίπτωση σφάλματος. Η σύνταξη της εντολής είναι:\\
    \textlatin{On Error Resume Next}\\ ή \\\textlatin{On Error GoTo 0}.
    Τα δέντρα που παράγονται σε κάθε περίπτωση θα είναι της μορφής:\\
    \includegraphics{errornext} \includegraphics{errorzero}
    \item[\textlatin{Dim/ReDim}] Οι εντολές δηλώνουν μεταβλητές.
    Τα δέντρα θα έχουν την μορφή:\\
    \includegraphics[scale=0.85]{dim} \includegraphics[scale=0.85]{redim}
    \item[\textlatin{Erase}] Απομακρύνει αντικείμενα από την μνήμη και
    αποδεσμεύει το χώρο που καταλάμβαναν.\\
    \includegraphics{erase}
    \item[\textlatin{Call}] Καλεί μία συνάρτηση ή μέθοδο κάποιας κλάσης.
    Εάν η συνάρτηση επιστρέφει κάποια τιμή, το αποτέλεσμα της συνάρτησης δεν
    είναι προσπελάσιμο.\\
    \includegraphics{call} \includegraphics{callobj}
    \item[\textlatin{Set}] Αποθηκεύει σε μία μεταβλητή ένα αντικείμενο.\\
    \includegraphics{set}
    \item[\textlatin{Randomize}] Αρχικοποιεί τον παραγωγό τυχαίων αριθμών.\\
    \includegraphics{randomize}
    \item[\textlatin{Const}] Η εντολή δηλώνει μία σταθερά.\\
    \includegraphics{const} \newpage
    \item[\textlatin{Sub}] Δηλώνει μία συνάρτηση που δεν επιστρέφει τιμή.
    Εάν η συνάρτηση δέχεται παραμέτρους, οι παράμετροι αφαιρούνται από το δέντρο
    και αποθηκεύονται σε εσωτερικές δομές δεδομένων.\\
    \includegraphics{sub}
    \item[\textlatin{Function}] Δηλώνει συναρτήσεις που επιστρέφουν τιμή. Ο
    χειρισμός της εντολής δεν διαφέρει σημαντικά από την \textlatin{Sub}.
    \item[\textlatin{While/Whend}] Ορίζει βρόχους.\\
    \includegraphics{whend}\\
    Ο βρόχος θα τερματιστεί όταν η λογική έκφραση λάβει την τιμή \term{false}.
    \item[\textlatin{With}] Στο εσωτερικό της εντολής \textlatin{With} δεν είναι
    αναγκαίο να αναφέρεται ρητά το όνομα της μεταβλητής όπου έχει αποθηκευτεί
    ένα αντικείμενο.\\
    \includegraphics{with}
    \item[\textlatin{Do/While}]
    Ορίζει βρόχους που τερματίζονται όταν η λογική έκφραση λάβει την τιμή
    \textlatin{false}.
    \item[\textlatin{Do/Until}]
    Η εντολή είναι παρόμοια με την \textlatin{Do/While}. Η συγκεκριμένη μορφή
    βρόχου εγγυάται ότι ο βρόχος θα εκτελεστεί τουλάχιστον μία φορά.
    \item[\textlatin{For}]
    Άλλη μια μορφή βρόχου.\\
    \includegraphics{vbfor}
    \includegraphics{vbfor2}
    \item[\textlatin{For Each}]
    Η εντολή δίνει την δυνατότητα να εξεταστούν οι ιδιότητες ενός αντικειμένου
    ή τα μέλη ενός πίνακα διαδοχικά. Το δέντρο που κατασκευάζεται από την εντολή
    έχει την παρακάτω μορφή:\\
    \includegraphics{vbforeach}\\
    Η ιδιότητα ή το μέλος του πίνακα αποθηκεύεται προσωρινά στην μεταβλητή σε
    κάθε βρόχο.
    \item[\textlatin{If/ElseIf/Else}]
    Η εντολή ορίζει σημεία διακλάδωσης στον κώδικα. Τα \textlatin{ElseIf} και
    \textlatin{Else} είναι προαιρετικά.\\
    \includegraphics{vbif}
    \item[\textlatin{Select}]
    Η εντολή \textlatin{Select} αποτελεί έναν εναλλακτικό τρόπος ορισμού σημείων
    διακλάδωσης του κώδικα.Το δέντρο που προκύπτει από την εντολή έχει την
    μορφή:\\
    \includegraphics{vbselect}
\end{description}


\subsection{Δομή αρχείων \textlatin{XML}}
Τα αρχεία \textlatin{XML} του \textlatin{ASPA} διακρίνονται σε δύο κατηγορίες:
\begin{itemize}
    \item Αρχεία που περιγράφουν συναρτήσεις που δεν ανήκουν σε κάποια κλάση.
    Σε αυτά τα αρχεία, το στοιχείο-ρίζα του εγγράφου \textlatin{XML} ονομάζεται
    \textlatin{functions}. Κάθε μέθοδος αποτελεί ένα στοιχείο στο έγγραφο, το
    οποίο είναι παιδί του στοιχείου \textlatin{functions}.
    \item Αρχεία που περιγράφουν κλάσεις τις οποίες παρέχει η \textlatin{ASP}
    ή κλάσεις \textlatin{ActiveX}. Το στοιχείο-ρίζα σε αυτά τα έγγραφα
    ονομάζεται \textlatin{class}.
\end{itemize}

Τα στοιχεία που απαντώνται στα αρχεία \textlatin{XML} του \textlatin{ASPA}
είναι τα παρακάτω:
\begin{itemize}
    \item
    \begin{description}
        \item[Όνομα:] \textlatin{functions}
        \item[Χρήση:] Είναι το στοιχείο - ρίζα εγγράφων που περιγράφουν
        συναρτήσεις που δεν ανήκουν σε κάποια κλάση.
        \item[Στοιχεία - παιδιά:] \textlatin{method}
    \end{description}

    \item
    \begin{description}
        \item[Όνομα:] \textlatin{method}
        \item[Χρήση:] Ορίζει μια μέθοδο (\textlatin{function, procedure})
        \item[Ιδιότητες:]
            \begin{itemize}
                \item[]
                \item[-] \textit{\textlatin{name}}   το όνομα της μεθόδου
                \item[-] \textit{\textlatin{type}}   ο τύπος της επιστρεφομένης
                τιμής
                \item[-] \textit{\textlatin{id}}  το αναγνωριστικό της μεθόδου.
                Το αναγνωριστικό, σε αντίθεση με το όνομα, είναι μοναδικό για
                κάθε μέθοδο.
                \item[-] \textit{\textlatin{requires}}  εξωτερικά αρχεία που
                απαιτούνται. Σε ορισμένες περιπτώσεις, ο παραγόμενος κώδικας
                για να εκτελεστεί χωρίς λάθη, προϋποθέτει την ύπαρξη
                συναρτήσεων οι οποίες δηλώνονται σε εξωτερικά αρχεία.
                Το \textlatin{requires} ορίζει τα αρχεία που πρέπει
                να ενσωματωθούν στον κώδικα.
                \item[-] \textit{\textlatin{default}}  παίρνει τιμές
                \textlatin{true} ή \textlatin{false}. Στην \textlatin{ASP}
                μια κλάση είναι δυνατόν να έχει μια προκαθορισμένη μέθοδο.
                Εάν η τιμή της ιδιότητας είναι \textlatin{true} τότε η μέθοδος
                θεωρείται ως η προκαθορισμένη μέθοδος της κλάσης.
                Για παράδειγμα, η κλάση \textlatin{Request} έχει ως
                προκαθορισμένη μέθοδο την \textlatin{QueryString}, με
                αποτέλεσμα  η έκφραση \textlatin{Request("a")} να είναι
                ισοδύναμη με την έκφραση \textlatin{Request.QueryString("a")}.
                \item[-] \textit{\textlatin{use}}  το όνομα μιας κλάσης που θα
                χρησιμοποιηθεί αντί της μεθόδου. Όταν ορίζεται το \textlatin{use}
                τότε η πληροφορία που απαιτείται για τη μετάφραση δεν παρέχεται
                από τη μέθοδο, αλλά από τη κλάση την οποία χρησιμοποιεί.
                Θα αναφέρουμε ένα παράδειγμα για να διασαφηνίσουμε την έννοια
                του \textlatin{use}:
                Έστω ότι έχουμε τα παρακάτω:\\
                \par
                \textlatin{
                Request.Cookies \\
                Request.Cookies("a") \\
                Request.Cookies("a").hasKeys \\
                Request.Cookies("a")("b")\\
                }
                \par
                Στο πρώτο το \textlatin{Cookies} παρουσιάζεται σαν ιδιότητα
                της κλάσης \textlatin{Request}. Στο δεύτερο το
                \textlatin{Cookies} φαίνεται να είναι μέθοδος του
                \textlatin{Request}, στο τρίτο μέθοδος του \textlatin{Request}
                που επιστρέφει κλάση, με την ιδιότητα \textlatin{hasKeys} και
                τέλος στο τέταρτο φτάνουμε σε αδιέξοδο, διότι ούτε μέθοδος
                φαίνεται να είναι, ούτε ιδιότητα. Το πρόβλημα λύνεται
                θεωρώντας ότι η ιδιότητα \textlatin{Cookies} του
                \textlatin{Request} αναφέρεται σε μια κλάση που θα ονομάσουμε
                \textlatin{Cookies}. Με βάση τη θεώρηση αυτή, η ερμηνεία του
                κώδικα έχει ως εξής: Στην πρώτη έκφραση καλούμε την
                προκαθορισμένη ιδιότητα της κλάσης \textlatin{Cookies}. Στη
                δεύτερη καλούμε την προκαθορισμένη μέθοδο της κλάσης
                \textlatin{Cookies}. Από την τρίτη γραμμή γίνεται σαφές πως η
                προκαθορισμένη μέθοδος της κλάσης \textlatin{Cookies} επίσης
                επιστρέφει αντικείμενο κάποιας κλάσης (ας την ονομάσουμε
                \textlatin{SubCookie}) με την ιδιότητα \textlatin{hasKeys}.
                Τέλος, η τέταρτη έκφραση αναφέρετε στην προκαθορισμένη μέθοδο
                της κλάσης \textlatin{SubCookie}.
            \end{itemize}
            \item[Στοιχεία - παιδιά:] \textlatin{arg, ast, this}
    \end{description}
    \item
    \begin{description}
        \item[Όνομα:] \textlatin{arg}
        \item[Χρήση:] Ορίζει μια παράμετρο μιας μεθόδου ή ιδιότητας κλάσης
        \item[Ιδιότητες:]
            \begin{itemize}
                \item[]
                \item[-] \textit{\textlatin{type}}  ο αναμενόμενος τύπος της
                παραμέτρου. Η ιδιότητα \textlatin{type} ορίζεται μόνο εφόσον
                το γονικό στοιχείο του \textlatin{arg} είναι το
                \textlatin{method} ή \textlatin{property}.
                \item[-] \textit{\textlatin{index}}  είναι ο αριθμός της
                παραμέτρου στην οποία αναφερόμαστε. Ο αριθμός της πρώτης
                παραμέτρου είναι "1". Η ιδιότητα \textlatin{index} ορίζεται
                εφόσον το γονικό στοιχείο του \textlatin{arg} είναι το
                \textlatin{ast}.
            \end{itemize}
    \end{description}
    \item
    \begin{description}
        \item[Όνομα:] \textlatin{ast}
        \item[Χρήση:] Είναι ένας κόμβος \textlatin{AST}.
        \item[Ιδιότητες:]
            \begin{itemize}
                \item[]
                \item[-] \textit{\textlatin{name}}  Το όνομα του \textlatin{AST}
                κόμβου. Κάθε κόμβος έχει μοναδικό όνομα, που προσδιορίζει τον
                τύπο του.
                \item[-] \textit{\textlatin{text}} Το κείμενο του κόμβου.
                Σε κάποιους κόμβους το κείμενο αγνοείτε εάν έχει οριστεί.
            \end{itemize}
        \item[Στοιχεία - παιδιά:] \textlatin{ast, arg, this}
    \end{description}
    \item
    \begin{description}
        \item[Όνομα:] \textlatin{this}
        \item[Χρήση:] Συμβολίζει την τρέχουσα υλοποίηση \textlatin{(instance)}
        του αντικειμένου.
    \end{description}
    \item
    \begin{description}
        \item[Όνομα:] \textlatin{constructor}
        \item[Χρήση:] Αντιπροσωπεύει μία ειδική μέθοδο που καλείται για την
        κατασκευή υλοποιήσεων αντικειμένων κάποιας κλάσης.
        \item[Στοιχεία - παιδιά:] \textlatin{arg, ast, this}
    \end{description}
    \item
    \begin{description}
        \item[Όνομα:] \textlatin{class}
        \item[Χρήση:] Αντιστοιχεί σε μία κλάση. Το πρώτο στοιχείο
        \textlatin{class} είναι η ρίζα του εγγράφου \textlatin{XML}.
        \item[Ιδιότητες:]
            \begin{itemize}
                \item[]
                \item[-] \textit{\textlatin{name}}  Το όνομα της κλάσης.
                \item[-] \textit{\textlatin{standalone}}  Εάν η τιμή της
                ιδιότητες είναι \textlatin{true}, τότε μπορούν να παραχθούν
                αντικείμενα της κλάσης, διαφορετικά, αντικείμενα της κλάσης
                παράγονται μόνο ως αποτέλεσμα της κλήσης μιας μεθόδου.
                \item[-] \textit{\textlatin{dependant}}  Εάν η τιμή της
                ιδιότητας είναι \textlatin{true}, τότε δεν μπορεί να υπάρχουν
                αντικείμενα της κλάσης. Η κλάση χρησιμοποιείται από κάποια
                μέθοδο μέσω της ιδιότητας \textlatin{use}.
                \item[-] \textit{\textlatin{requires}}  εξωτερικά αρχεία που
                απαιτούνται.
            \end{itemize}
        \item[Στοιχεία - παιδιά:] \textlatin{class, constructor, property,
        method}
    \end{description}
    \item
    \begin{description}
        \item[Όνομα:] \textlatin{property}
        \item[Χρήση:] Το στοιχείο \textlatin{property} ορίζει μία ιδιότητα
        κάποιας κλάσης. Οι κλάσεις της \textlatin{ASP}, μπορεί να έχουν
        ιδιότητες που είναι μόνο για ανάγνωση, μόνο για αποθήκευση τιμών ή
        ιδιότητες που υποστηρίζουν και τις δύο λειτουργίες. Μπορούμε να
        θεωρήσουμε πως μία ιδιότητα αντιστοιχεί σε δύο μεθόδους, μία για την
        ανάγνωση της τιμής της, και μία δεύτερη που αλλάζει την τιμή της
        ιδιότητας.
        \item[Ιδιότητες:] Έχει τις ίδιες ιδιότητες, με εξαίρεση το
        \textlatin{id}, με το στοιχείο \textlatin{method}.
        \item[Στοιχεία - παιδιά:]
            \begin{itemize}
                \item[]
                \item[-] \textlatin{read} ορίζεται μόνο εφόσον η ιδιότητα
                υποστηρίζει την ανάγνωση της τρέχουσας τιμής της.
                \item[-] \textlatin{write} ορίζεται μόνο εφόσον η ιδιότητα
                υποστηρίζει την αλλαγή της τρέχουσας τιμής της.
                \item[-] \textlatin{arg} ορίζεται μόνο εφόσον υπάρχει το στοιχείο
                \textlatin{write}
            \end{itemize}
    \end{description}
    \item
    \begin{description}
        \item[Όνομα:] \textlatin{read}
        \item[Χρήση:] Ορίζει την μετάφραση της ιδιότητας όταν ζητείτε η τιμή της.
        \item[Στοιχεία - παιδιά:] \textlatin{ast, this}
    \end{description}
    \item
    \begin{description}
        \item[Όνομα:] \textlatin{write}
        \item[Χρήση:] Ορίζει την μετάφραση της ιδιότητας όταν της ανατίθεται νέα
        τιμή.
        \item[Στοιχεία - παιδιά:] \textlatin{ast, arg, this, state}. Το στοιχείο
        \textlatin{arg} μπορεί να έχει μόνο την ιδιότητα \textlatin{index}.
    \end{description}
    \item
    \begin{description}
        \item[Όνομα:] \textlatin{state}
        \item[Χρήση:] Το στοιχείο \textlatin{state} καθορίζει την μέθοδο της
        οποίας οι παράμετροι θα επηρεάζονται όταν νέα τιμή ανατίθεται στην
        ιδιότητα όπου το \textlatin{state} υπάρχει.
        \item[Ιδιότητες:]
            \begin{itemize}
                \item[]
                \item[-] \textit{\textlatin{methodId}} Το αναγνωριστικό της
                μεθόδου. Σε κάθε αναγνωριστικό αντιστοιχεί μία μόνο μέθοδος.
                \item[] \textit{\textlatin{index}} Καθορίζει την παράμετρο που
                θα επηρεασθεί
            \end{itemize}
    \end{description}
\end{itemize}


\subsection{Μοντελοποίηση Κλάσεων}
Για τον χειρισμό των κλάσεων της \textlatin{ASP} χρειαζόμαστε δομές δεδομένων
όπου θα αντανακλώνται οι σχέσεις και οι ιδιότητες των κλάσεων. Παρακάτω
περιγράφονται οι δομές δεδομένων που χρησιμοποιούμε, και ο σκοπός και η σημασία
της κάθε δομής.\\
\includegraphics{classes}
Στο σχήμα, σε κύκλο βρίσκονται τα \textlatin{interfaces} και σε παραλληλόγραμμο
οι κλάσεις.

Στην βάση της ιεραρχίας βρίσκεται το \textlatin{ASPObject} που ορίζει τις
βασικές ιδιότητες που έχει κάθε κλάση. Οι μέθοδοι είναι:
\begin{description}
    \item[\textlatin{getName}] επιστρέφει το όνομα του αντικειμένου. Κάθε κλάση,
    ιδιότητα ή μέθοδος της \textlatin{ASP} έχει ένα όνομα.
    \item[\textlatin{addDependency}] προσθέτει το όνομα ενός αρχείου που
    απαιτείται για να λειτουργήσει ο παραγόμενος κώδικας. Οι εξαρτήσεις μπορεί
    να οφείλονται στη χρήση κάποιας κλάσης, μεθόδου ή ιδιότητας της κλάσης.
    Εάν για παράδειγμα η μέθοδος \textlatin{method} κάποιας κλάσης απαιτεί ένα
    αρχείο, το αρχείο θα συμπεριληφθεί στον παραγόμενο κώδικα \textlatin{PHP},
    μόνο εφόσον κληθεί η μέθοδος. Αντίθετα, εάν η εξάρτηση οφείλεται στην
    κλάση της μεθόδου \textlatin{method}, τότε θα συμπεριληφθεί στον παραγόμενο
    κώδικα οποτεδήποτε κληθεί κάποια από της μεθόδους ή ιδιότητες της κλάσης.
    \item[\textlatin{getDependencies}] επιστρέφει τα ονόματα όλων των
    εξαρτήσεων του αντικειμένου.
    \item[\textlatin{resetState}] επαναφέρει την εσωτερική κατάσταση του
    αντικειμένου στην αρχική.
\end{description}

Άμεσος απόγονος του \textlatin{ASPObject} είναι το \textlatin{ASPClass} που
αντιπροσωπεύει μία κλάση της \textlatin{ASP}. Τα αντικείμενα της κλάσης
\textlatin{ASPClass} παρέχουν τη δυνατότητα αναζήτησης μεθόδων και ιδιοτήτων
που υποστηρίζει η κλάση. Αναλυτικά, το \textlatin{ASPClass} περιέχει τις
παρακάτω επιπλέον μεθόδους από το \textlatin{ASPObject}:
\begin{description}
    \item[\textlatin{getMemberObject(String name)}] επιστρέφει ένα μέλος της
    κλάσης που το όνομα είναι ίδιο με την παράμετρο \textlatin{name}.
    \item[\textlatin{getMemberList(String name)}] επιστρέφει μία λίστα που
    περιέχει όλα τα μέλη της κλάσης των οποίων το όνομα είναι ίδιο με την
    παράμετρο \textlatin{name}.
    \item[\textlatin{isStandalone}] εάν αντικείμενα της κλάσης μπορούν να
    αρχικοποιηθούν, η επιστρεφόμενη τιμή της μεθόδου είναι αληθής.
    Ορισμένες κλάσεις όπως το \textlatin{Request} και το \textlatin{Math} δεν
    μπορούν να έχουν αντικείμενα ενώ από τις κλάσεις όπως το \textlatin{String}
    και το \textlatin{Date} μπορούν να κατασκευαστούν αντικείμενα.
    \item[\textlatin{getDefaultProperty}] επιστρέφει την προκαθορισμένη ιδιότητα
    της κλάσης.
    \item[\textlatin{getDefaultMethod}] επιστρέφει την προκαθορισμένη μέθοδο της
    κλάσης.
    \item[\textlatin{getDeleteAST}] όταν το αντικείμενο μίας κλάσης δεν
    χρειάζεται πλέον, καταστρέφεται. Εάν κάποιες ενέργειες πρέπει να λάβουν χώρα
    κατά την καταστροφή του αντικειμένου, η μέθοδος επιστρέφει τις απαιτούμενες
    ενέργειες κωδικοποιημένες με την μορφή δέντρου \textlatin{AST}.
    \item[\textlatin{hasConstructor}] εάν η κλάση περιέχει μία ειδική μέθοδο που
    καλείται για την κατασκευή ενός νέου αντικειμένου της κλάσης, τότε η
    επιστρεφόμενη τιμή της μεθόδου είναι αληθής.
    \item[\textlatin{getConstructors}] επιστρέφει μία λίστα με όλες τις μεθόδους
    που χρησιμοποιούνται για την κατασκευή αντικειμένων της κλάσης.
    \item[\textlatin{addConstructor}] προσθέτει μία μέθοδο ικανή να κατασκευάζει
    αντικείμενα της κλάσης.
    \item[\textlatin{addMember}] προσθέτει μία ιδιότητα ή μέθοδο στην κλάση.
    \item[\textlatin{isCaseSensitive}] επιστρέφει τιμή αληθή εάν τα ονόματα των
    μελών της κλάσης διαφοροποιούνται από πεζά και κεφαλαία γράμματα.
    \item[\textlatin{getProperties}] επιστρέφει μία λίστα με όλες τις ιδιότητες
    της κλάσης.
    \item[\textlatin{getMethods}] επιστρέφει μία λίστα με όλες τις μεθόδους
    της κλάσης.
    \item[\textlatin{getMembers}] επιστρέφει μία λίστα με όλες τις ιδιότητες και
    τις μεθόδους της κλάσης.
\end{description}

Η απόγονος κλάση του \textlatin{ASPClass} είναι η \textlatin{ASPDependantClass}
που προσθέτει μία επιπλέον μέθοδο, την \textlatin{setDependantMember}. Η μέθοδος
θέτει το μέλος κάποιας άλλης κλάσης που εξαρτάται από την κλάση που
αντιπροσωπεύει το \textlatin{ASPDependantClass}.

Το \textlatin{ASPObject} επεκτείνεται και από την κλάση \textlatin{Member} που
αντιπροσωπεύει ένα μέλος μίας κλάσης. Μέλη θεωρούνται όλες οι μέθοδοι και οι
ιδιότητες της κλάσης. Οι επιπλέον μέθοδοι που προσφέρει το \textlatin{Member}
είναι:
\begin{description}
    \item[\textlatin{getReturnType}] επιστρέφει έναν κωδικό αριθμό που
    αντιστοιχεί στον τύπο της επιτρεπομένης τιμής του μέλους.
    \item[\textlatin{setReturnType}] θέτει τον κωδικό της επιστρεφομένης τιμής.
    \item[\textlatin{getEvaluatedClass}] επιστρέφει την κλάση από την οποία
    εξαρτάται το μέλος.
    \item[\textlatin{setEvaluatedClass}] θέτει την κλάση από την οποία εξαρτάται
    το μέλος.
    \item[\textlatin{setArgs}] θέτει την λίστα από παραμέτρους που δέχεται το
    μέλος όταν κληθεί.
    \item[\textlatin{getArgs}] επιστρέφει την λίστα από παραμέτρους που δόθηκαν
    στο μέλος την τελευταία φορά που κλήθηκε
    \item[\textlatin{setClass}] θέτει την κλάση όπου ανήκει το μέλος.
    \item[\textlatin{getASPClass}] επιστρέφει την κλάση όπου ανήκει το μέλος.
    \item[\textlatin{setRetObjectClass}] θέτει την κλάση όπου ανήκει η
    επιστρεφόμενη τιμή εάν το μέλος επιστρέφει αντικείμενο.
    \item[\textlatin{getRetObjectClass}] επιστρέφει την κλάση όπου ανήκει η
    επιστρεφόμενη τιμή του μέλους.
\end{description}

Η κλάση \textlatin{Member} περιέχει τις κοινές μεθόδους μεταξύ των ιδιοτήτων και
των μεθόδων μιας κλάσης, όμως οι δύο κατηγορίες μελών έχουν επιπλέον ιδιότητες.
Τις επιπλέον ιδιότητες εκφράζουν οι δύο απόγονοι της κλάσης \textlatin{Member},
η κλάση \textlatin{Method} και \textlatin{Property} που αντιπροσωπεύουν τις
μεθόδους και τις ιδιότητες μιας κλάσης αντίστοιχα.

Η κλάση \textlatin{Method} έχει τις παρακάτω μεθόδους:
\begin{description}
    \item[\textlatin{translate}] επιστρέφει ένα \textlatin{AST} δέντρο που
    κωδικοποιεί \textlatin{PHP} κώδικα αντίστοιχης λειτουργικότητας.
    Η μετάφραση συνήθως είναι κλήση της αντίστοιχης μεθόδου της
    \textlatin{PHP} όμως μπορεί να είναι πιο
    περίπλοκη και να αποτελείται από μία σειρά δηλώσεων και εκφράσεων της
    \textlatin{PHP} που επιτυγχάνουν το ίδιο αποτέλεσμα με την μέθοδο της
    \textlatin{ASP} που αντιπροσωπεύει το αντικείμενο της κλάσης
    \textlatin{Method}.
    \item[\textlatin{getArgTypes}] επιστρέφει μια λίστα με τους τύπους δεδομένων
    της κάθε παραμέτρου που δέχεται η μέθοδος.
    \item[\textlatin{isConstructor}] επιστρέφει τιμή αληθή εάν η μέθοδος
    χρησιμοποιείται για την κατασκευή αντικειμένων της κλάσης όπου ανήκει.
    \item[\textlatin{setConstructor}] δίνει τη δυνατότητα να σημανθεί η μέθοδος
    ως κατασκευαστής αντικειμένων.
\end{description}

Η κλάση \textlatin{Property} αποτελεί εξειδίκευση της κλάσης \textlatin{Member}.
Κάθε ιδιότητα μιας κλάσης μπορεί να προσφέρει την δυνατότητα επαναπροσδιορισμού
της τιμής της, ανάγνωσης της τιμής ή και τα δύο. Επιπλέον, στην περίπτωση
ανάθεσης τιμής σε μία ιδιότητα, μπορεί να καθοριστεί μόνο μία παράμετρος.
Αναλυτικά η μέθοδοι της κλάσης \textlatin{Property} είναι:
\begin{description}
    \item[\textlatin{read}] επιστρέφει την μετάφραση της ανάγνωσης της τιμής της
    ιδιότητας σε \textlatin{PHP} σε μορφή \textlatin{AST}.
    \item[\textlatin{write}] επιστρέφει ένα δέντρο \textlatin{AST} που
    αντιστοιχεί στην μετάφραση της ανάθεσης τιμής στην ιδιότητα σε
    \textlatin{PHP}.
    \item[\textlatin{setArgType}] θέτει τον τύπο της παραμέτρου που δέχεται η
    ιδιότητα, όταν της ανατίθεται νέα τιμή.
    \item[\textlatin{setIndicatedMethod}] σε ορισμένες περιπτώσεις, η ανάθεση
    τιμής σε μία ιδιότητα επηρεάζει τις παραμέτρους κάποιας μεθόδου. Η μέθοδος
    \protect{\textlatin{setIndicatedMethod}} παρέχει την δυνατότητα καθορισμού
    της μεθόδου που επηρεάζεται από την ανάθεση τιμών στην ιδιότητα.
\end{description}

Από τις υλοποιήσεις των παραπάνω κλάσεων αξίζει να αναφερθούμε στην κλάση
\textlatin{UserDefinedMethod} που αντιστοιχεί σε μεθόδους ορισμένες από τον
προγραμματιστή σε μία σελίδα \textlatin{ASP}. Οι μέθοδοι που ορίζονται σε κάποια
σελίδα παρουσιάζουν ιδιότητες που δεν απαντώνται στις προκαθορισμένες μεθόδους
της \textlatin{ASP} ή στις μεθόδους των \textlatin{ActiveX}. Στο σώμα της
δήλωσης της μεθόδου, μπορούν να δηλωθούν και άλλες μέθοδοι, που με τη σειρά τους
μπορούν να έχουν άλλες εσωτερικές μεθόδους και ούτω καθεξής. Επίσης, οι μέθοδοι
μπορούν να έχουν τοπικές μεταβλητές ή να χρησιμοποιούν μεταβλητές ορισμένες
εκτός αυτών \textlatin{(global variables)}. Είναι σημαντικό να επισημάνουμε πως
υπάρχουν κανόνες που καθορίζουν την ορατότητα των μεταβλητών και των μεθόδων που
ορίζονται στο σώμα μίας μεθόδου. Η κλάση \textlatin{UserDefinedMethod}
εξασφαλίζει πως οι μεταφραστές ακολουθούν τους κανόνες ορατότητας μεταβλητών.
Επιπλέον, οι απόγονοι της κλάσης \textlatin{UserDefinedMethod} φροντίζουν για
την σωστή μετάφραση των μεθόδων του προγραμματιστή, σε \textlatin{PHP}.

\subsubsection{Κατασκευή αναπαραστάσεων των κλάσεων από \textlatin{XML}}
Όπως αναφέραμε παραπάνω, οι εγγενείς κλάσεις της \textlatin{ASP} καθώς και τα
\textlatin{ActiveX} περιγράφονται μέσω \textlatin{XML}. Οι κλάσεις όμως δεν
μπορούν να χρησιμοποιηθούν εάν δεν μετατραπούν πρώτα σε αντικείμενα των κλάσεων
που περιγράψαμε παραπάνω. Την μετατροπή των αναπαραστάσεων \textlatin{XML} σε
αντικείμενα των κλάσεων \textlatin{ASPClass}, \textlatin{Property} και
\textlatin{Method} αναλαμβάνει η κλάση \textlatin{XmlObjectParser}.

Το \textlatin{XmlObjectParser} αποκωδικοποιεί την πληροφορία που αποθηκεύεται
στα \textlatin{XML} αρχεία με την βοήθεια εξωτερικών βιβλιοθηκών και αξιοποιεί
τις πληροφορίες για την κατασκευή των κατάλληλων αντικειμένων. Για κάθε κλάση
που περιγράφεται στα \textlatin{XML} αρχεία, κατασκευάζεται ένα αντικείμενο της
κλάσης \textlatin{XmlAspClass}, απόγονου της \textlatin{ASPClass}, και
προστίθενται στο αντικείμενο οι ιδιότητες και οι μέθοδοι που ανήκουν στην
κλάση. Επιπλέον, εάν υπάρχουν μέθοδοι που δεν ανήκουν σε κάποια κλάση,
μετατρέπονται σε αντικείμενα της κλάσης \textlatin{Method} και δίνονται στον
μεταφραστή.


Όπως έχουμε ήδη αναφέρει, σε κάθε μέθοδο ή ιδιότητα, αντιστοιχεί ένα δέντρο
\textlatin{AST}. Στα \textlatin{XML} αρχεία, ο τύπος του \textlatin{AST} κόμβου
ορίζεται με ένα γενικό όνομα. Ως παράδειγμα αναφέρουμε την περίπτωση ορισμού
ενός κόμβου που αντιστοιχεί σε κλήση μεθόδου. Στο \textlatin{XML} αρχείο η κλήση
μεθόδου γράφεται ως:\selectlanguage{english}
\begin{verbatim}
<ast name="METHOD_CALL" text="MethodName">
\end{verbatim}\selectlanguage{greek}
Ο κόμβος \textlatin{AST} που θα παραχθεί, πρέπει να έχει έναν τύπο που
καθορίζεται από την τιμή της ιδιότητας \textlatin{name}. Το πρόβλημα είναι πως
ο τύπος δεν είναι ίδιος για τις γλώσσες \textlatin{JScript} και
\textlatin{VbScript}. Το \textlatin{XmlObjectParser} προσδιορίζει το κατάλληλο
τύπο για κάθε γλώσσα με βάση το όνομα του κόμβου, και προσδίδει στο κόμβο τον
τύπο που βρήκε.

\subsection{Μεταφραστές}
Η διαδικασία της μετάφρασης αφορά την μετατροπή του αρχικού δέντρου
\textlatin{AST} που κατασκευάστηκε κατά την διαδικασία της συντακτικής ανάλυσης
σε δέντρο \textlatin{AST} διαφορετικής δομής. Μπορούμε να διακρίνουμε δύο
κατηγορίες μετάφρασης, την μετατροπή συντακτικών δομών σε ανάλογες δομές της
\textlatin{PHP} και την μετάφραση κλήσεων σε συναρτήσεις με κλήσης σε
αντίστοιχες συναρτήσεις της \textlatin{PHP} ή με την αντικατάσταση τους από
δηλώσεις και εκφράσεις που επιτυγχάνουν το ίδιο αποτέλεσμα.

Το πρώτο είδος μετατροπής επιτυγχάνεται εξολοκλήρου από τους μεταφραστές. Οι
μεταφραστές αναγνωρίζουν τμήματα του δέντρου \textlatin{AST} που έλαβαν από τον
συντακτικό αναλυτή και το μετατρέπουν σε δομή συμβατή με την \textlatin{PHP}.

\subsubsection{Συντακτικές μετατροπές της \textlatin{JScript}}
    \begin{itemize}
    \item Όταν ο τελεστής '+' ενώνει δύο εκφράσεις εκ των οποίων μία τουλάχιστον
    είναι τύπου \textlatin{String}, τότε αντικαθίσταται από τον τελεστή
    '.'.
    \item Εκφράσεις του τύπου
    \selectlanguage{english}
    \verb+a = a op b+
    \selectlanguage{greek}
    αντικαθιστώνται από
    \selectlanguage{english}
    \verb+a op= b+.
    \selectlanguage{greek}
    \item Ο τελεστής \term{typeof} αντικαθίσταται ανάλογα με τον τύπο της
    δεξιάς έκφρασης από:
    \begin{itemize}
        \item[-] Όταν ο τύπος δεν είναι \term{String} επιλέγεται η έκφραση\\
        \textlatin{gettype(expr)}, όπου \textlatin{expr} είναι η έκφραση στα
        αριστερά του τελεστή.
        \item[-] Όταν ο τύπος είναι \term{String} τότε ανάλογα με την τιμή της
        έκφρασης επιλέγονται τα παρακάτω:\\
        \selectlanguage{english}
        \begin{itemize}
            \item[number] \includegraphics{number}
            \item[boolean] \verb+(is_bool[METHOD_CALL] (ELIST expr))+
            \item[string] \verb+(is_string[METHOD_CALL] (ELIST expr))+
            \item[object] \verb+(is_object[METHOD_CALL] (ELIST expr))+
            \item[function] \verb+(function_exists[METHOD_CALL] (ELIST expr))+
            \item[undefined] \verb+(isset[METHOD_CALL] (ELIST expr))+
        \end{itemize}
        \selectlanguage{greek}
        \item[-] Ο τελεστής \term{instanceof} αντιμετωπίζεται με παρόμοιο τρόπο με τον
        \term{typeof}.
        \item[-] Ο τελεστής \term{delete} αντικαθίσταται από την έκφραση\\
        \selectlanguage{english}\verb+(unset[METHOD_CALL] (ELIST expr))+
        \selectlanguage{greek}
        \item[-] Απομακρύνονται τα \textlatin{label}.
        \item[-] Όταν οι εντολές \term{break} και \term{continue} δείχνουν σε κάποιο
        \term{label} και βρίσκονται σε βρόχο, τότε το \term{label}
        αντικαθίσταται από έναν κατάλληλο αριθμό, ώστε το αποτέλεσμα να είναι το
        ίδιο. Εάν οι εντολές δεν βρίσκονται σε βρόχο, τότε πρόκειται για την εντολή
        \term{goto} την οποία δεν υποστηρίζει η \term{PHP} και δεν μεταφράζεται.
        \item[-] Ο κώδικας που βρίσκεται στο εσωτερικό της εντολής \term{with}
        επεκτείνεται ώστε να περιλαμβάνει και το όνομα του αντικειμένου.
        Για παράδειγμα ο κώδικας:
        \selectlanguage{english}
        \listCode{with.txt}
        \selectlanguage{greek}
        αντιμετωπίζεται το ίδιο με το κώδικα:
        \selectlanguage{english}
        \listCode{withexp.txt}
        \selectlanguage{greek}
        \item[-] Τα \textlatin{else if} αντικαθιστώνται με το \textlatin{elseif}
    \end{itemize}
    \end{itemize}
    \selectlanguage{greek}
    Η \term{JScript}, υποστηρίζει κλάσεις, αλλά ο τρόπος δήλωσης τους
    παρουσιάζει κάποιες ιδιαιτερότητες.
    Μία μέθοδος ανήκει σε κλάση εάν:
    \begin{itemize}
        \item Αναφέρεται στο αντικείμενο \term{this}.
        \item Αναφέρεται από άλλη μέθοδο που ανήκει στην κλάση σε μία έκφραση
        της μορφής:\\
\selectlanguage{english}
\verb+this.someName = aName+
\selectlanguage{greek}\\
        όπου το \textlatin{someName} ορίζει το όνομα του μέλους και το
        \textlatin{aName} είναι το όνομα της μεθόδου.
    \end{itemize}
\selectlanguage{greek}
    Μέλη της κλάσης θα είναι επίσης και όσες μεταβλητές ορίζονται με τον
    παραπάνω τρόπο.

    Συνήθως υπάρχει μία κεντρική μέθοδος που εκτελεί χρέη \term{constructor}.
    Για να προσδιοριστεί η μέθοδος ελέγχεται εάν:
    \begin{itemize}
        \item Υπάρχει μέθοδος που αναφέρεται σε άλλες μεθόδους με την μορφή
\selectlanguage{english}
\verb+this.someName = aName+
\selectlanguage{greek}
        \\αλλά καμία άλλη δεν αναφέρεται σε εκείνη με τον ίδιο τρόπο.
        \item Στην περίπτωση όπου δεν υπάρχει καμία τέτοια μέθοδος ή
        υπάρχουν παραπάνω από μία, επιλέγεται εκείνη που έχει χρησιμοποιηθεί
        μετά από την εντολή \term{new}
    \end{itemize}
\selectlanguage{greek}
Όταν έχει πλέον προσδιοριστεί η κεντρική μέθοδος της κλάσης και τα μέλη της,
κατασκευάζεται η κλάση της \term{PHP} με τις παρακάτω ιδιότητες:
\begin{itemize}
    \item Το όνομα της κλάσης θα είναι το όνομα της μεθόδου που λειτουργεί
    ως \term{constructor}.
    \item Κάθε μέθοδος που ανήκει στην κλάση θα μεταφερθεί από το σημείο
    δήλωσής της, στο εσωτερικό της κλάσης.
    \item Για τις μεταβλητές που ανήκουν στην κλάση και αρχικοποιούνται
    ταυτόχρονα με την δήλωσή τους, κατασκευάζεται η δήλωσή της στο εσωτερικό
    της κλάσης και ο κώδικας της αρχικοποίησης μεταφέρεται στο
    \term{constructor}.
    \item Οι ολικές(\term{global scope}) μεταβλητές δηλώνονται με την εντολή
    \term{global}.
\end{itemize}
Παραθέτουμε ένα παράδειγμα των μετατροπών που λαμβάνουν χώρα για την μετάφραση
των κλάσεων.
\selectlanguage{english}
\listCode{js_class.txt}
\selectlanguage{greek}
Οι συναρτήσεις \textlatin{getX} και \textlatin{setX} αναφέρονται στην μεταβλητή
\term{this}, οπότε ανήκουν σε κάποια κλάση. Παρατηρούμε ότι η συνάρτηση
\textlatin{Point} αναφέρεται στις συναρτήσεις \textlatin{getX} και
\textlatin{setX}, αλλά καμία συνάρτηση δεν αναφέρεται στην \textlatin{Point}.
Θα πρέπει λοιπόν, η συνάρτηση \textlatin{Point} να θεωρηθεί ως ο
\term{constructor} της κλάσης. Τέλος, στην συνάρτηση \textlatin{Point},
δηλώνεται και αρχικοποιείται η μεταβλητή \textlatin{x}. Τελικά, η κλάση της
\term{PHP} θα έχει την μορφή:
\selectlanguage{english}
\listCode{php_class.txt}
\selectlanguage{greek}

\subsubsection{Συντακτικές μετατροπές της \textlatin{VbScript}}
\begin{itemize}
    \item Ο τελεστής \term{impl} αντικαθίσταται με την έκφραση:
    \selectlanguage{english}
    \begin{verbatim}
(NOT
  (AND lexpr
    (NOT rexpr)
  )
)\end{verbatim}
    \selectlanguage{greek}
    \item Ο τελεστής \term{eqv} αντικαθίσταται με την έκφραση:
    \selectlanguage{english}
    \verb+(NOT (XOR lexpr rexpr))+
    \selectlanguage{greek}
    \item Αντικατάσταση του τελεστή $\backslash$ (διαίρεση χωρίς υπόλοιπο) με
    την έκφραση:\\
    \selectlanguage{english}
    \begin{verbatim}
(ceil[METHOD_CALL]
  (ARGLIST_VALUES
    (DIVIDE lexpr rexpr)
  )
)\end{verbatim}
    \selectlanguage{greek}
    \item Αντικατάσταση του τελεστή \begin{Large}\^{}\end{Large} με την έκφραση:
    \selectlanguage{english}
    \begin{verbatim}
(pow[METHOD_CALL]
  (ARGLIST_VALUES lexpr  rexpr)
)\end{verbatim}
    \selectlanguage{greek}
    \item Η εντολή \term{randomize} αντικαθίσταται με την μέθοδο \term{srand}
    \item Μεταφράζει δηλώσεις σταθερών (\term{const}) με την εντολή
    \term{define} της \term{PHP}
    \item Αντικαθιστά την εντολή \term{erase} με την εντολή \term{unset}
    \item Η εντολή \term{exit} ανάλογα με την λέξη κλειδί που έπεται
    αντικαθίσταται με:
    \begin{description}
        \item[\textlatin{Do}] \textlatin{break}
        \item[\textlatin{For}] \textlatin{break}
        \item[\textlatin{Sub}] \textlatin{return}
        \item[\textlatin{Function}] \textlatin{(return expr)}
        \item[\textlatin{Property}] Δεν υποστηρίζεται!
    \end{description}
    \item Τα \textlatin{else if} αντικαθιστώνται με το \textlatin{elseif}
    \item Το \term{do while condition \ldots loop} μεταφράζεται σε \term{while}
    \item Η εντολή \term{do until condition \ldots loop} μετατρέπεται σε
    \term{while} όπου η έκφραση \term{condition} αντιστρέφεται. Ανάλογα με τον
    τελεστή που είναι ρίζα της έκφρασης \term{condition} η νέα ρίζα θα είναι:\\
    \begin{tabular}{|c | c|}
        \cline{1-2}
        Τελεστής & Τελικός Τελεστής\\
        \cline{1-2}
        \textless & \textgreater=\\
        \textgreater & \textless=\\
        \textless= & \textgreater\\
        \textgreater= & \textless\\
        != & ==\\
        == & !=\\
        ! & απαλείφεται\\
        \cline{1-2}
    \end{tabular}\\ \\
    Εάν η ρίζα δεν είναι κανένα από τα παραπάνω, κατασκευάζεται δέντρο του
    οποίου ρίζα θα είναι το \textlatin{!} και πρώτο παιδί της ρίζας θα είναι
    η προηγούμενη έκφραση.
    \item Η εντολή \term{do \ldots loop until condition} μετατρέπεται σε
    \term{do \ldots while} όπου η έκφραση \term{condition} αντιστρέφεται.
    \item Η \term{while \ldots wend} μετατρέπεται σε \term{while}
    \item Η \term{select case} μετατρέπεται σε \term{switch} με τις παρακάτω
    επιπλέον αλλαγές:
    \begin{itemize}
        \item[-] Εάν κάποιο \term{case} έχει παραπάνω από μία τιμές ελέγχου,
        αντικαθίσταται με μία σειρά από \term{case} εντολές ίσες στο πλήθος όσο
        οι τιμές και μόνο η τελευταία θα περιέχει την εντολή \term{break}
        \item[-] Στο τέλος της κάθε \term{case}, προστίθεται η εντολή \term{break}
        \item[-] Η \term{case else} αντικαθίσταται με την \term{default}
    \end{itemize}
    Παρακάτω παραθέτουμε ένα παράδειγμα σε ψευδοκώδικα των μετατροπών.
    \selectlanguage{english}
\listCode{case.txt}
    \selectlanguage{greek}
    Ο κώδικας, αφου θα έχει υποστεί τις μετατροπές που αναφέραμε παραπάνω, θα
    είναι της μορφής:
    \selectlanguage{english}
\listCode{casetrans.txt}
    \selectlanguage{greek}
    \item Η εντολή \selectlanguage{english}
    \verb+for counter = start to end [step s]+ \selectlanguage{greek} ορισμένες
    φορές μετατρέπεται σε εντολή \term{while}. Η μετατροπή θα γίνει εφόσον:
    \begin{itemize}
        \item[-] Έχει οριστεί η παράμετρος \term{step}
        \item[-] Η τιμή της παραμέτρου είναι κλήση σε μέθοδο ή μέλος κλάσης.
    \end{itemize}
    \item Τα \term{sub} μετατρέπονται σε \term{function} με επιστρεφόμενο τύπο
    \term{void}
    \item Στα \term{function} και \term{sub} δηλώνονται οι ολικές μεταβλητές
    που χρησιμοποιούν, με την εντολή \term{global}
    \item Εξασφαλίζεται ότι οι συναρτήσεις πάντα θα επιστρέφουν τιμή. Για να
    εξασφαλιστεί το παραπάνω θα πρέπει να:
    \begin{enumerate}
        \item Δηλώνεται η μεταβλητή \term{result}.
        \item Οι εκφράσεις του τύπου \selectlanguage{english}
        \verb+funcName = expr+\selectlanguage{greek} μετατρέπονται σε
        \selectlanguage{english} \verb+result = expr+.\selectlanguage{greek}
        \item Η εντολή \term{exit function} μετατρέπεται σε \term{return result}.
        \item Όταν ο \term{VbsTree} φτάσει στο τέλος της \term{function} και
        δεν έχει επιστραφεί τιμή, τότε εισάγει την εντολή \term{return result}.
    \end{enumerate}
\end{itemize}

\selectlanguage{greek}
\subsection{Παραγωγή κώδικα}
Το τελευταίο άρθρωμα (\textlatin{module}) του προγράμματος αναλαμβάνει τη
μετατροπή των δέντρων που κατασκεύασαν οι μεταφραστές σε πηγαίο κώδικα. Το
άρθρωμα αποτελείται από δύο αναλυτές δέντρων (\textlatin{TreeParser}
\cite{bib:treeparser}) που προσπελαύνουν τον κάθε κόμβο του δέντρου και μία
κλάση (\textlatin{SourceBuffer}), που φροντίζει για την σωστή δομή του κώδικα.

Ο κώδικας οφείλει να υπακούει στους συντακτικούς κανόνες της \term{PHP} και να
είναι στοιχισμένος ώστε να διευκολύνεται η περαιτέρω ανάπτυξη της σελίδας από
τον προγραμματιστή.

Ο \textlatin{SourceBuffer} προσφέρει τις παρακάτω μεθόδους στους
\textlatin{TreeParser}:
\begin{description}
    \item[\textlatin{print}] Η παράμετρος της μεθόδου ενδέχεται να είναι είτε
    ένας χαρακτήρας ή μια συμβολοσειρά. Η μέθοδος εισάγει το σύμβολο
    \textlatin{<?php} εάν είναι αναγκαίο και μεριμνά για την στοίχιση προτού
    τυπώσει την παράμετρο.
    \item[\textlatin{println}] Το ίδιο με την μέθοδο \textlatin{print} μόνο που
    τυπώνεται και ο χαρακτήρας τέλους γραμμής.
    \item[\textlatin{printHTML}] Εκτυπώνει χαρακτήρες που δεν είναι κώδικας σε
    \term{PHP} και εισάγει το σύμβολο
    \selectlanguage{english}?\textgreater \selectlanguage{greek}, εάν είναι
    απαραίτητο.
    \item[\textlatin{incLevel}] Αυξάνει κατά ένα τον βαθμό στοίχισης.
    \item[\textlatin{decLevel}] Μειώνει κατά ένα τον βαθμό στοίχισης.
    \item[\textlatin{makeString}] Μετατρέπει μία συμβολοσειρά σε μορφή αποδεκτή
    από την \term{PHP}.
    \item[\textlatin{end}] Εισάγει το σύμβολο
    \selectlanguage{english}?\textgreater \selectlanguage{greek}, εάν είναι
    απαραίτητο. Η μέθοδος καλείται όταν η μετατροπή του δέντρου σε πηγαίο κώδικα
    έχει ολοκληρωθεί.
\end{description}
\selectlanguage{greek}
Οι \textlatin{TreeParser}, όταν επισκέπτονται τον κάθε κόμβο του τελικού δέντρου
,καλούν την κατάλληλη μέθοδο του \textlatin{SourceBuffer} ώστε να παραχθεί ο
κώδικας για τον κόμβο. Παραθέτουμε κάποια παραδείγματα ώστε να διασαφηνισθεί η
διαδικασία.
\begin{description}
    \item[\textlatin{html}] Όταν ο κόμβος περιέχει απλό κείμενο, δεν περιέχει
    δηλαδή κώδικα της \term{PHP}, καλείται η μέθοδος \textlatin{printHTML}, με
    παράμετρο το κείμενο του κόμβου.
    \item[Αναγνωριστικά, αριθμοί και λέξεις κλειδιά] Καλείται η μέθοδος
    \textlatin{print} με παράμετρο το κείμενο του κόμβου. Εάν ο κόμβος είναι
    αναγνωριστικό, τότε μεριμνά να μην παραβιάζονται κανόνες ονοματοδοσίας της
    \term{PHP} προτού κληθεί η μέθοδος.
    \item[Σύνθετες δομές] Εντολές όπως η \textlatin{if, for} κ.α ενδέχεται να
    περιέχουν και άλλες εντολές στο εσωτερικό τους. Για να διασφαλιστεί η σωστή
    στοίχιση του παραγόμενου κώδικα, καλείται η μέθοδος \textlatin{incLevel}
    προτού ξεκινήσει η παραγωγή κώδικα για την εντολή, και η μέθοδος
    \textlatin{decLevel} όταν έχει ολοκληρωθεί η διαδικασία.
    \item[Συμβολοσειρές] Η μέθοδος \textlatin{makeString} καλείται για τις
    συμβολοσειρές, ώστε να λάβουν την κατάλληλη μορφή.
\end{description}

\section{Έλεγχος Εγκυρότητας}
Καθώς το \textlatin{ASPA} σταδιακά υλοποιούσε την αναγνώριση και την μετάφραση
της \textlatin{ASP}, η πολυπλοκότητα του κώδικα αυξανόταν. Η βελτίωση
ενός τμήματος του \textlatin{ASPA} προκαλούσε λόγω προγραμματιστικών λαθών
δυσλειτουργίες σε άλλα τμήματα του προγράμματος. Η ανάγκη για την ύπαρξη
ελέγχου εγκυρότητας γινόταν επιτακτική καθώς η πολυπλοκότητα αυξανόταν.

Η τακτική που ακολουθήσαμε είναι απλή. Για κάθε επιπλέον λειτουργικότητα που
έπρεπε να προστεθεί στο \textlatin{ASPA}, κατασκευάζαμε ένα αρχείο εισόδου που
χρησιμοποιεί το επιθυμητό χαρακτηριστικό. Για παράδειγμα, όταν έπρεπε να
υλοποιηθεί η αναγνώριση της σύνταξης της εντολής \textlatin{if} της
\textlatin{VBScript}, κατασκευάσαμε ένα αρχείο που περιέχει διάφορες τέτοιες
εντολές. Αρχικά βέβαια το \textlatin{ASPA} δεν μπορούσε να επεξεργαστεί το
αρχείο, αλλά  με την συγγραφή επιπλέον κώδικα και μετά από πολλές δοκιμές
τελικά ο  στόχος επιτεύχθει.

Πώς μπορούμε να
είμαστε βέβαιοι, ότι οι μελλοντικές επεμβάσεις στον κώδικα του \textlatin{ASPA},
δεν θα καταστήσουν αδύνατη την επεξεργασία του αρχείου εισόδου; Ο προφανής
τρόπος είναι να δοκιμάσουμε μετά από κάθε επέμβαση στον κώδικα, αν όλα τα
αρχεία εισόδου μπορούν να αναλυθούν χωρίς λάθη. Αν η δοκιμή θα έπρεπε να γίνει
χειροκίνητα, ο τρόπος ελέγχου γρήγορα θα έπαυε να είναι πρακτικός, καθώς το
πλήθος των δοκιμαστικών αρχείων εισόδου αυξανόταν. Αλλά η αυτοματοποίηση των
ελέγχων δεν είναι δύσκολη υπόθεση. Θα μπορούσαμε να συγγράψουμε ένα σενάριο
κελύφους \textlatin{(shell script)} που θα έλεγχε για λάθη κατά την διάρκεια
ανάλυσης των αρχείων. Αν και αυτή η λύση είναι καλύτερη, δεν είναι
ικανοποιητική. Θα ήταν θεμιτό να γνωρίζουμε όχι μόνο το όνομα του αρχείου του
οποίου η ανάλυση απέτυχε, αλλά και άλλες πληροφορίες, όπως η γραμμή του αρχείου
όπου παρατηρήθηκε το σφάλμα, και τα αίτια του σφάλματος. Επιπλέον, θα μπορούσε,
όπως και συνέβη πολλές φορές, το \textlatin{ASPA} να επεξεργαστεί το αρχείο
χωρίς σφάλματα κατά την ανάλυση, αλλά το αποτέλεσμα της ανάλυσης να είναι
λανθασμένο. Τελικά η λύση δόθηκε από την παρατήρηση ότι τόσο στην φάση της
συντακτικής ανάλυσης όσο και της μετάφρασης, παράγονται δέντρα \textlatin{AST}.
Εάν τα δέντρα μπορούσαν να αποθηκευτούν σε αρχεία, τότε η αναμενόμενη έξοδος για
κάθε αρχείο εισόδου θα ήταν γνωστή εκ των προτέρων. Το μόνο που χρειάζεται για
να ελεγχθεί η σωστή λειτουργία του \textlatin{ASPA} είναι η σύγκριση μεταξύ των
δέντρων \textlatin{AST} που παράγει η τρέχουσα έκδοση του \textlatin{ASPA}, με
τα δέντρα \textlatin{AST} αποθηκευμένα στα αρχεία.

Ο αυτοματισμός της διαδικασίας ελέγχου, υλοποιείται από το \textlatin{JUnit}. Το
\textlatin{JUnit} πληροφορείται ποιους ελέγχους πρέπει να πραγματοποιήσει από
ένα αντικείμενο της κλάσης \protect{\textlatin{junit.framework.TestSuite}}.
Το \textlatin{TestSuite}
περιέχει αντικείμενα της κλάσης \protect{\textlatin{junit.framework.TestCase}}
όπου κάθε \textlatin{TestCase} αντιστοιχεί σε έναν έλεγχο. Η κλάση
\protect{\textlatin{gr.omadak.leviathan.asp.ASPSuite}} κατασκευάζει ένα
\textlatin{TestSuite} που περιέχει όλα τα σενάρια ελέγχου που πρέπει να
εκτελεστούν. Κάθε σενάριο ελέγχου, χρειάζεται για την εκτέλεσή του, ένα αρχείο
εισόδου και ένα αρχείο \textlatin{XML} όπου έχει αποθηκευτεί η δομή των
αναμενόμενων δέντρων \textlatin{AST}.

Για λόγους ευκολίας, η αντιστοιχία αρχείου εισόδου και \textlatin{XML} αρχείου,
βρίσκεται σε ένα αρχείο κειμένου με την παρακάτω δομή:\\
Στην πρώτη γραμμή γράφονται το ονόματα του φακέλου όπου βρίσκονται τα αρχεία
εισόδου, ακολουθεί ο χαρακτήρας ":" και έπειτα γράφεται το όνομα του φακέλου
όπου βρίσκονται τα αρχεία \textlatin{XML}. Οι υπόλοιπες γραμμές περιέχουν το
όνομα του αρχείου εισόδου, τον χαρακτήρα ":", το όνομα του αρχείου
\textlatin{XML} όπου αποθηκεύεται η αναμενόμενη δομή των δέντρων \textlatin{AST},
και όταν το αρχείο εισόδου περιέχει κώδικα σε \textlatin{VBScript} ακολουθεί και
πάλι ο χαρακτήρας ":". Ο λόγος που διακρίνονται τα \textlatin{VBScript} αρχεία
εισόδου από όσα περιέχουν κώδικα \textlatin{JScript} θα διασαφηνισθεί
στην συνέχεια. Το \textlatin{ASPSuite} διαβάζει το αρχείο όπου περιγράφονται
οι αντιστοιχίες, και για κάθε γραμμή, πλην της πρώτης, κατασκευάζει ένα
\textlatin{TestCase}.

Το \textlatin{JUnit} προσφέρει το πλαίσιο εργασίας, αλλά ο πραγματικός έλεγχος
πραγματοποιείται από την κλάση
\protect{\textlatin{gr.omadak.leviathan.asp.ASPTest}} που αποτελεί επέκταση της
κλάσης \protect{\textlatin{junit.framework.TestCase}}. Κάθε υλοποίηση
\textlatin{(instance)} της κλάσης \textlatin{ASPTest} ελέγχει ένα μόνο αρχείο
εισόδου. Από το αρχείο εισόδου κατασκευάζεται το δέντρο που προκύπτει από την
διαδικασία συντακτικής ανάλυσης. Εάν η συντακτική ανάλυση προκαλέσει σφάλμα,
τότε θεωρείται πως ο έλεγχος απέτυχε. Εφόσον δεν υπάρξει σφάλμα, από το αρχείο
\textlatin{XML} κατασκευάζεται η αναμενόμενη δομή του δέντρου που προέκυψε από
την συντακτική ανάλυση του αρχείου εισόδου. Κάθε κόμβος του δέντρου
\textlatin{AST} ελέγχεται εάν έχει τον αναμενόμενο τύπο και κείμενο. Εάν
το δέντρο προέκυψε από κώδικα \textlatin{VBScript}, ο έλεγχος του κειμένου
γίνεται χωρίς να λαμβάνονται υπόψιν διαφορές πεζών και κεφαλαίων γραμμάτων. Το
\textlatin{ASPTest} γνωρίζει εάν πρόκειται για αρχείο \textlatin{VBScript}
επειδή η αντίστοιχη γραμμή στο αρχείο ρυθμίσεων των ελέγχων τελειώνει με τον
χαρακτήρα ":". Έπειτα ελέγχεται εάν ο κόμβος έχει το αναμενόμενο πλήθος
παιδιών-κόμβων, και στη συνέχεια το \textlatin{ASPTest} πραγματοποιεί τους
ίδιους ελέγχους για τους κόμβους-παιδιά.
Σε περίπτωση αποτυχίας του ελέγχου, γνωρίζουμε το όνομα του αρχείου εισόδου
όπου παρατηρήθηκε το σφάλμα, καθώς και τον κόμβο \textlatin{AST} που έχει
διαφορετικές ιδιότητες (τύπος, κείμενο, παιδιά) από τις αναμενόμενες. Εάν το
δέντρο που προέκυψε από την συντακτική ανάλυση δεν έχει αλλάξει, τότε το
\textlatin{ASPTest} κατασκευάζει το μεταφρασμένο δέντρο \textlatin{AST}, και
πραγματοποιεί τους ίδιους ελέγχους στο δέντρο που προέκυψε.

Με τον παραπάνω τρόπο, ελέγχονται και η διαδικασία συντακτικής ανάλυσης
και η διαδικασία μετάφρασης. Η διαδικασία λεκτικής ανάλυσης ελέγχεται έμμεσα,
διότι εάν ο λεκτικός αναλυτής δυσλειτουργεί, τα δέντρα \textlatin{AST} θα έχουν
διαφορετική δομή από την αναμενόμενη.

\section{Εγχειρίδιο Χρήσης}
Το \textlatin{ASPA} προσφέρει δύο τρόπους εκτέλεσης, τα σενάρια κελύφους
\textlatin{run} και \textlatin{parse}. Το \textlatin{run} προσφέρει επιλογές που
είναι χρήσιμες σε όσους ασχοληθούν με την περαιτέρω ανάπτυξη του προγράμματος,
ενώ το \textlatin{parse} προορίζεται για τον τελικό χρήστη.

Οι επιλογές που αναγνωρίζει το \textlatin{run} είναι:
\begin{description}
    \item[\textlatin{-t}] τα \textlatin{token} που κατασκευάζουν οι λεκτικοί
    αναλυτές τυπώνονται στην οθόνη. Η επιλογή είναι χρήσιμη όταν η διαδικασία
    συντακτικής ανάλυσης αποτύχει με σφάλμα και θέλουμε να εξετάσουμε το
    \textlatin{token} που προκάλεσε το σφάλμα.
    \item[\textlatin{-v}] ο χρήστης μπορεί να εξετάσει τα δέντρα που παράγουν οι
    συντακτικοί αναλυτές και οι μεταφραστές σε γραφικό περιβάλλον. Η επιλογή
    είναι απαραίτητη κατά την διαδικασία ανάπτυξης της εφαρμογής διότι δίνει τη
    δυνατότητα να εξετάσουμε εάν η δομή των δέντρων είναι η επιθυμητή.
    \item[\textlatin{-x}] τα δέντρα που παράγονται αποθηκεύονται σε ένα αρχείο
    \textlatin{XML} σε μορφή ίδια με εκείνη που απαιτείται για τον έλεγχο
    εγκυρότητας. Η επιλογή χρησιμοποιείται όταν θέλουμε να παράξουμε ένα
    καινούργιο αρχείο ελέγχου ή όταν κάποιος έλεγχος αποτυγχάνει μπορούμε να
    εξετάσουμε εύκολα τις διαφορές που υπάρχουν μεταξύ του αρχείου και του
    αναμενόμενου αποτελέσματος με ένα πρόγραμμα όπως το \textlatin{diff}.
    \item[\textlatin{-s}] παράγει κώδικα \textlatin{PHP} από το αρχείο εισόδου.
\end{description}
Οι επιλογές είναι προαιρετικές. Εάν δεν δοθεί καμία από της παραπάνω,
τότε το πρόγραμμα θα αναλύσει το κώδικα αλλά δεν θα παράξει κανένα αποτέλεσμα.
Επιπλέον, το πρόγραμμα αναμένει το όνομα του αρχείου προς ανάλυση και τον φάκελο
που θεωρείται η ρίζα των αρχείων της εφαρμογής \textlatin{web}. Συνήθως ο
φάκελος έχει την διαδρομή \protect{\textlatin{C:/inetpub/wwwroot}}.

Οι επιλογές που δέχεται το \textlatin{parse} είναι:
\begin{description}
    \item[\textlatin{-b}] μετά την παράμετρο ορίζεται η διαδρομή του φακέλου όπου
    βρίσκονται τα αρχεία προς μετάφραση. Θα μεταφραστούν μόνο τα αρχεία που
    έχουν κατάληξη \textlatin{asp} και δεν έχουν ήδη μεταφραστεί.
    \item[\textlatin{-o}] ορίζει την διαδρομή του φακέλου όπου αποθηκεύονται τα
    μεταφρασμένα αρχεία.
    \item[\textlatin{-s}] ορίζει την διαδρομή του βασικού φακέλου της
    \textlatin{web} εφαρμογής. Η διαδρομή χρησιμοποιείται για τον προσδιορισμό
    της πλήρους διαδρομής αρχείων που συμπεριλαμβάνονται σε άλλα αρχεία με την
    μέθοδο \textlatin{virtual}. Για παράδειγμα:
    \textlatin{\textless!\-\-\#include virtual="somePath.inc"\-\->}
    \item[\textlatin{-ng}] εάν οριστεί η παράμετρος, τότε δεν θα παραχθεί
    κώδικας σε \textlatin{PHP}. Το πρόγραμμα ωστόσο θα αναλύσει τα αρχεία και θα
    εμφανίσει μηνύματα λάθους εάν υπάρξουν.
    \item[\textlatin{-js}] θέτει την \textlatin{JScript} ως την
    προκαθορισμένη γλώσσα των σελίδων. Εάν δεν οριστεί η παράμετρος, τότε η
    προκαθορισμένη γλώσσα είναι η \textlatin{VbScript}.
\end{description}

\section{Περαιτέρω Ανάπτυξη}
Λόγω περιορισμών κατά το χρόνο διεκπεραίωσης της εφαρμογής, ορισμένα τμήματα
δεν υλοποιήθηκαν ή η υλοποίησή τους δεν είναι επαρκής.
\subsection{Προς υλοποίηση}
    \begin{itemize}
        \item Οι κανονικές εκφράσεις αναγνωρίζονται από τους αναλυτές αλλά
        δεν μεταφράζονται σε ισοδύναμες κανονικές εκφράσεις της \term{PHP}.
        \item Τα σχόλια που υπάρχουν στο πηγαίο κώδικα απορρίπτονται από
        τους αναλυτές. Θα ήταν θεμιτό τα σχόλια να διατηρούνται. Σημαντική
        δυσκολία παρουσιάζει η εισαγωγή των σχολίων στην κατάλληλη θέση στον
        παραγόμενο κώδικα όταν έχουμε ανακατατάξεις του κώδικα όπως συμβαίνει
        με τις κλάσεις της \term{JScript}.
        \item Οι κλάσεις της \term{VbScript} δεν μεταφράζονται. Η υλοποίηση δεν
        παρουσιάζει μεγάλες δυσκολίες διότι η δομή των κλάσεων είναι όμοια στις
        δύο γλώσσες.
        \item Η \term{JScript} υποστηρίζει δύο τρόπους δήλωσης κλάσεων. Από
        τους δύο εναλλακτικούς τρόπους, το \term{ASPA} μεταφράζει μόνο τον ένα.
        Ακολουθεί η δήλωση της κλάσης \textlatin{Point} με τους δύο
        εναλλακτικούς τρόπους εκ των οποίων μόνο ο πρώτος αναγνωρίζεται:
        \selectlanguage{english}
        \begin{enumerate}
        \item
        \listCode{point.txt}


        \item
        \listCode{short_point.txt}
        \end{enumerate}
        \selectlanguage{greek}
        \item Στην \term{VbScript} οι τελεστές \textlatin{or, and} και
        \textlatin{xor} ανάλογα με τον τύπο των εκφράσεων που βρίσκονται
        εκατέρωθεν των τελεστών, λειτουργούν είτε ως λογικοί τελεστές είτε ως
        τελεστές δυαδικών πράξεων (\textlatin{bitwise operator}).
        Η \term{PHP} παρέχει διαφορετικούς τελεστές για τις λογικές και δυαδικές
        πράξεις. Είναι αναγκαίο λοιπόν το \term{ASPA} να κατανοήσει την ιδιότητα
        του τελεστή ώστε να μεταφράσει ορθά τον κώδικα. Προκειμένου να
        αποφανθούμε για τον τύπο των εκφράσεων σε ορισμένες περιπτώσεις
        απαιτούνται πληροφορίες οι οποίες είναι διαθέσιμες μόνο κατά την
        εκτέλεση του κώδικα. Για το λόγο αυτό το πρόβλημα δεν λύνεται πάντα,
        όμως το \term{ASPA} θα μπορούσε να επιχειρήσει να δώσει λύση όταν είναι
        εφικτό.
        \item Όταν μία σελίδα εξαρτάται από άλλες, θα πρέπει να
        κοινοποιούνται ορισμένες πληροφορίες στους \term{Lexer} που αναλύουν
        κάθε μία από τις σελίδες. Η κοινοποίηση είναι απαραίτητη μόνο εφόσον
        οι σελίδες περιέχουν κώδικα σε \term{VbScript}. Η υλοποίηση παρουσιάζει
        σημαντική δυσκολία και είναι απαραίτητη όταν δηλώνονται πίνακες σε μία
        σελίδα που αξιοποιούνται από την άλλη.
        \item Μία σελίδα της \term{ASP} (ή πολλές σελίδες που αλληλοεξαρτώνται),
        μπορούν να περιέχουν κώδικα σε διαφορετικές γλώσσες. Για την σωστή
        μετάφραση του κώδικα πρέπει να ανταλλάσσονται πληροφορίες μεταξύ των
        \term{Parser} των διαφορετικών γλωσσών. Η παρούσα υλοποίηση προσφέρει
        υποτυπώδεις δυνατότητες ανταλλαγής πληροφοριών και πρέπει να επεκταθεί
        ώστε να λειτουργήσει σωστά.
    \end{itemize}
    \selectlanguage{greek}
    \subsection{Πιθανές χρήσεις τμημάτων του \textlatin{ASPA}}
    Επιπλέον, το \textlatin{ASPA} μπορεί να χρησιμεύσει ως παράδειγμα,
    αλλά και ως βάση για την ανάπτυξη παρόμοιων εφαρμογών, γεγονός
    που οφείλεται στην αρθρωτή δομή του.
    \begin{itemize}
    \item
    Οι λεκτικοί και συντακτικοί αναλυτές του \textlatin{ASPA} μπορούν να
    χρησιμοποιηθούν σε εφαρμογές οι οποίες θα κάνουν ανάλυση κώδικα
    \textlatin{JScript} ή \textlatin{VBScript}, με στόχο:
    \begin{itemize}
        \item[-]
        Στοίχιση και βελτίωση της εμφάνισης του κώδικα
        \item[-]
        Έλεγχο για την τήρηση συμβάσεων, όπως ονόματα μεταβλητών, συναρτήσεων,
        μέγιστο πλήθος εντολών ανά συνάρτηση κ.α.
        \item[-]
        Ανίχνευση συχνών λαθών ή λαθών που υπάγονται σε μια συγκεκριμένη κατηγορία
        \item[-]
        Εξαγωγή πληροφοριών από τον κώδικα
    \end{itemize}
    \item
    Το \textlatin{ASPA} μπορεί να χρησιμοποιηθεί για την ανάπτυξη μεταφραστή
    από \textlatin{ASP} σε άλλες γλώσσες πέραν της \textlatin{PHP}
    \item
    Μια επέκταση του \textlatin{ASPA} θα μπορούσε να αναγνωρίζει και άλλες
    γλώσσες προγραμματισμού, εκτός από \textlatin{JScript} και
    \textlatin{VBScript}
    \end{itemize}
\section{Συμπεράσματα}
\begin{itemize}
    \item Το \term{ASPA} έχει αρθρωτή (\textlatin{modular}) δομή που συνεισφέρει
    στην:
    \begin{itemize}
        \item[-] ευκολότερη επέκταση και συντήρηση του προγράμματος
        \item[-] χρήση ορισμένων αρθρωμάτων σε άλλα προγράμματα
    \end{itemize}
    \item Η χρήση της \term{xml} για την περιγραφή των \term{ActiveX}
    διασφαλίζει την:
    \begin{itemize}
    \item[-] εύκολη επέκταση του \term{ASPA}, ώστε να αναγνωρίζει επιπλέον
    \term{ActiveX}
    \item[-] αλλαγή της μετάφρασης για ορισμένα \term{ActiveX} ή μεθόδων τους,
    εάν ο χρήστης το επιθυμεί
    \end{itemize}
    \item Η επιλογή του \term{Antlr} για την κατασκευή των \term{Lexer},
    \term{Parser} και \term{TreeParser}, αποτέλεσε σημαντική παράμετρο στην
    ταχύτερη ανάπτυξη του \term{ASPA} και διευκολύνει την μελλοντική επέκταση
    του
    \item Το \term{ASPA} συνοδεύεται από 65 \term{Test Cases}, και από εργαλεία
    που προσφέρουν την υποδομή για την κατασκευή επιπλέον δοκιμαστικών αρχείων.
\end{itemize}

\section{Ευχαριστίες}
Η ομάδα συζητήσεων του \textlatin{antlr} ήταν πρόθυμη να απαντήσει σε ερωτήματα
που αναδύονταν κατά τη διάρκεια εκπόνησης της εργασίας. Επιπλέον, ο λεκτικός και
ο συντακτικός αναλυτής της \textlatin{JScript}, προήλθε από μία τροποποιημένη
εκδοχή του λεκτικού και συντακτικού αναλυτή της \textlatin{Java} που
συμπεριλαμβάνεται με το \textlatin{antlr}.

Ο αναπληρωτής καθηγητής Χρήστος Δουλιγέρης και ο Δημήτρης Γλυνός που ήταν
υπεύθυνοι της παρούσης εργασίας συνέβαλαν με την καθοδήγησή τους.
\selectlanguage{english}
\begin{thebibliography}{aa}
\bibitem{bib:asp}
\url{http://msdn.microsoft.com/library/en-us/iissdk/iis/usingasp.asp}
\bibitem{bib:php} \url{http://www.php.net}
\bibitem{bib:jscript}
\url{http://msdn.microsoft.com/library/en-us/script56/html/js56jsoriJScript.asp}
\bibitem{bib:vbscript}
\url{http://msdn.microsoft.com/library/en-us/script56/html/vtoriVBScript.asp}
\bibitem{bib:cgi} \url{http://hoohoo.ncsa.uiuc.edu/cgi}
\bibitem{bib:activex}
\url{http://msdn.microsoft.com/workshop/components/activex/intro.asp}
\bibitem{bib:asp2php} \url{http://asp2php.naken.cc}
\bibitem{bib:gpl} \url{http://www.fsf.org/copyleft/gpl.html}
\bibitem{bib:jstrans} \url{http://www.design215.com/toolbox/translator}
\bibitem{bib:java} \url{http://java.sun.com}
\bibitem{bib:lexer} \url{http://www.antlr.org/doc/glossary.html#Lexer}
\bibitem{bib:token} \url{http://www.antlr.org/doc/glossary.html#Token}
\bibitem{bib:xml} \url{http://www.w3.org/XML}
\bibitem{bib:jflex} \url{http://jflex.de}
\bibitem{bib:javacc} \url{https://javacc.dev.java.net}
\bibitem{bib:antlr} \url{http://www.antlr.org}
\bibitem{bib:gnuflex} \url{http://www.gnu.org/software/flex}
\bibitem{bib:ast} \url{http://www.antlr.org/doc/glossary.html#AST}
\bibitem{bib:ebnf} \url{http://www.cl.cam.ac.uk/~mgk25/iso-ebnf.html}
\bibitem{bib:w3c} \url{http://www.w3.org}
\bibitem{bib:dom} \url{http://w3.org/DOM}
\bibitem{bib:sax} \url{http://www.saxproject.org}
\bibitem{bib:jdom} \url{http://www.jdom.org}
\bibitem{bib:dom4j} \url{http://www.dom4j.org}
\bibitem{bib:junit} \url{http://www.junit.org}
\bibitem{bib:ant} \url{http://ant.apache.org}
\bibitem{bib:lisp} \url{http://www.lisp.org}
\bibitem{bib:parser} \url{http://www.antlr.org/doc/glossary.html#Parser}
\bibitem{bib:treeparser} \url{http://www.antlr.org/doc/glossary.html#TreeParser}
\end{thebibliography}
\end{document}
